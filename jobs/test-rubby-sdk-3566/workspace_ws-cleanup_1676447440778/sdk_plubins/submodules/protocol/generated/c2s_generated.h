// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_C2S_ABBY_H_
#define FLATBUFFERS_GENERATED_C2S_ABBY_H_

#include "flatbuffers/flatbuffers.h"

#include "public_generated.h"

namespace abby {

struct ClientReqSn;
struct ClientReqSnBuilder;

struct ClientReqSpeed;
struct ClientReqSpeedBuilder;

struct ClientReqStop;
struct ClientReqStopBuilder;

struct ClientRptRemoteControl;
struct ClientRptRemoteControlBuilder;

struct ClientReqSwitchAuto;
struct ClientReqSwitchAutoBuilder;

struct ClientReqSwitchManual;
struct ClientReqSwitchManualBuilder;

struct ClientReqAutoStart;
struct ClientReqAutoStartBuilder;

struct ClientReqMapList;
struct ClientReqMapListBuilder;

struct ClientReqMapOccupancyGrid;
struct ClientReqMapOccupancyGridBuilder;

struct ClientReqMapSemantics;
struct ClientReqMapSemanticsBuilder;

struct ClientReqStartRegion;
struct ClientReqStartRegionBuilder;

struct ClientReqSceneDesc;
struct ClientReqSceneDescBuilder;

struct ClientReqAddSceneDesc;
struct ClientReqAddSceneDescBuilder;

struct ClientReqDelSceneDesc;
struct ClientReqDelSceneDescBuilder;

struct ClientRequestSetState;
struct ClientRequestSetStateBuilder;

struct ClientReqRecharge;
struct ClientReqRechargeBuilder;

struct ClientReqAddTimer;
struct ClientReqAddTimerBuilder;

struct ClientReqUpdateTimer;
struct ClientReqUpdateTimerBuilder;

struct ClientReqDelTimer;
struct ClientReqDelTimerBuilder;

struct ClientReqListTimer;
struct ClientReqListTimerBuilder;

struct ClientReqCleanMode;
struct ClientReqCleanModeBuilder;

struct ClientData;
struct ClientDataBuilder;

enum KeyType {
  KeyType_up = 0,
  KeyType_down = 1,
  KeyType_left = 2,
  KeyType_right = 3,
  KeyType_MIN = KeyType_up,
  KeyType_MAX = KeyType_right
};

inline const KeyType (&EnumValuesKeyType())[4] {
  static const KeyType values[] = {
    KeyType_up,
    KeyType_down,
    KeyType_left,
    KeyType_right
  };
  return values;
}

inline const char * const *EnumNamesKeyType() {
  static const char * const names[5] = {
    "up",
    "down",
    "left",
    "right",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyType(KeyType e) {
  if (flatbuffers::IsOutRange(e, KeyType_up, KeyType_right)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyType()[index];
}

enum ClientType {
  ClientType_NONE = 0,
  ClientType_ClientReqSn = 1,
  ClientType_ClientReqSpeed = 2,
  ClientType_ClientReqStop = 3,
  ClientType_ClientRptRemoteControl = 4,
  ClientType_ClientReqSwitchAuto = 5,
  ClientType_ClientReqSwitchManual = 6,
  ClientType_ClientReqAutoStart = 7,
  ClientType_ClientReqMapList = 8,
  ClientType_ClientReqMapOccupancyGrid = 9,
  ClientType_ClientReqMapSemantics = 10,
  ClientType_ClientReqStartRegion = 11,
  ClientType_ClientReqSceneDesc = 12,
  ClientType_ClientReqAddSceneDesc = 13,
  ClientType_ClientReqDelSceneDesc = 14,
  ClientType_ClientRequestSetState = 15,
  ClientType_ClientReqRecharge = 16,
  ClientType_ClientReqAddTimer = 17,
  ClientType_ClientReqUpdateTimer = 18,
  ClientType_ClientReqDelTimer = 19,
  ClientType_ClientReqListTimer = 20,
  ClientType_ClientReqCleanMode = 21,
  ClientType_MIN = ClientType_NONE,
  ClientType_MAX = ClientType_ClientReqCleanMode
};

inline const ClientType (&EnumValuesClientType())[22] {
  static const ClientType values[] = {
    ClientType_NONE,
    ClientType_ClientReqSn,
    ClientType_ClientReqSpeed,
    ClientType_ClientReqStop,
    ClientType_ClientRptRemoteControl,
    ClientType_ClientReqSwitchAuto,
    ClientType_ClientReqSwitchManual,
    ClientType_ClientReqAutoStart,
    ClientType_ClientReqMapList,
    ClientType_ClientReqMapOccupancyGrid,
    ClientType_ClientReqMapSemantics,
    ClientType_ClientReqStartRegion,
    ClientType_ClientReqSceneDesc,
    ClientType_ClientReqAddSceneDesc,
    ClientType_ClientReqDelSceneDesc,
    ClientType_ClientRequestSetState,
    ClientType_ClientReqRecharge,
    ClientType_ClientReqAddTimer,
    ClientType_ClientReqUpdateTimer,
    ClientType_ClientReqDelTimer,
    ClientType_ClientReqListTimer,
    ClientType_ClientReqCleanMode
  };
  return values;
}

inline const char * const *EnumNamesClientType() {
  static const char * const names[23] = {
    "NONE",
    "ClientReqSn",
    "ClientReqSpeed",
    "ClientReqStop",
    "ClientRptRemoteControl",
    "ClientReqSwitchAuto",
    "ClientReqSwitchManual",
    "ClientReqAutoStart",
    "ClientReqMapList",
    "ClientReqMapOccupancyGrid",
    "ClientReqMapSemantics",
    "ClientReqStartRegion",
    "ClientReqSceneDesc",
    "ClientReqAddSceneDesc",
    "ClientReqDelSceneDesc",
    "ClientRequestSetState",
    "ClientReqRecharge",
    "ClientReqAddTimer",
    "ClientReqUpdateTimer",
    "ClientReqDelTimer",
    "ClientReqListTimer",
    "ClientReqCleanMode",
    nullptr
  };
  return names;
}

inline const char *EnumNameClientType(ClientType e) {
  if (flatbuffers::IsOutRange(e, ClientType_NONE, ClientType_ClientReqCleanMode)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesClientType()[index];
}

template<typename T> struct ClientTypeTraits {
  static const ClientType enum_value = ClientType_NONE;
};

template<> struct ClientTypeTraits<abby::ClientReqSn> {
  static const ClientType enum_value = ClientType_ClientReqSn;
};

template<> struct ClientTypeTraits<abby::ClientReqSpeed> {
  static const ClientType enum_value = ClientType_ClientReqSpeed;
};

template<> struct ClientTypeTraits<abby::ClientReqStop> {
  static const ClientType enum_value = ClientType_ClientReqStop;
};

template<> struct ClientTypeTraits<abby::ClientRptRemoteControl> {
  static const ClientType enum_value = ClientType_ClientRptRemoteControl;
};

template<> struct ClientTypeTraits<abby::ClientReqSwitchAuto> {
  static const ClientType enum_value = ClientType_ClientReqSwitchAuto;
};

template<> struct ClientTypeTraits<abby::ClientReqSwitchManual> {
  static const ClientType enum_value = ClientType_ClientReqSwitchManual;
};

template<> struct ClientTypeTraits<abby::ClientReqAutoStart> {
  static const ClientType enum_value = ClientType_ClientReqAutoStart;
};

template<> struct ClientTypeTraits<abby::ClientReqMapList> {
  static const ClientType enum_value = ClientType_ClientReqMapList;
};

template<> struct ClientTypeTraits<abby::ClientReqMapOccupancyGrid> {
  static const ClientType enum_value = ClientType_ClientReqMapOccupancyGrid;
};

template<> struct ClientTypeTraits<abby::ClientReqMapSemantics> {
  static const ClientType enum_value = ClientType_ClientReqMapSemantics;
};

template<> struct ClientTypeTraits<abby::ClientReqStartRegion> {
  static const ClientType enum_value = ClientType_ClientReqStartRegion;
};

template<> struct ClientTypeTraits<abby::ClientReqSceneDesc> {
  static const ClientType enum_value = ClientType_ClientReqSceneDesc;
};

template<> struct ClientTypeTraits<abby::ClientReqAddSceneDesc> {
  static const ClientType enum_value = ClientType_ClientReqAddSceneDesc;
};

template<> struct ClientTypeTraits<abby::ClientReqDelSceneDesc> {
  static const ClientType enum_value = ClientType_ClientReqDelSceneDesc;
};

template<> struct ClientTypeTraits<abby::ClientRequestSetState> {
  static const ClientType enum_value = ClientType_ClientRequestSetState;
};

template<> struct ClientTypeTraits<abby::ClientReqRecharge> {
  static const ClientType enum_value = ClientType_ClientReqRecharge;
};

template<> struct ClientTypeTraits<abby::ClientReqAddTimer> {
  static const ClientType enum_value = ClientType_ClientReqAddTimer;
};

template<> struct ClientTypeTraits<abby::ClientReqUpdateTimer> {
  static const ClientType enum_value = ClientType_ClientReqUpdateTimer;
};

template<> struct ClientTypeTraits<abby::ClientReqDelTimer> {
  static const ClientType enum_value = ClientType_ClientReqDelTimer;
};

template<> struct ClientTypeTraits<abby::ClientReqListTimer> {
  static const ClientType enum_value = ClientType_ClientReqListTimer;
};

template<> struct ClientTypeTraits<abby::ClientReqCleanMode> {
  static const ClientType enum_value = ClientType_ClientReqCleanMode;
};

bool VerifyClientType(flatbuffers::Verifier &verifier, const void *obj, ClientType type);
bool VerifyClientTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ClientReqSn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqSnBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ClientReqSnBuilder {
  typedef ClientReqSn Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqSn::VT_TIME, time, 0);
  }
  explicit ClientReqSnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqSnBuilder &operator=(const ClientReqSnBuilder &);
  flatbuffers::Offset<ClientReqSn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqSn>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqSn> CreateClientReqSn(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  ClientReqSnBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ClientReqSpeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqSpeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINE_SPEED = 4,
    VT_ANGULAR_VELOCITY = 6
  };
  float line_speed() const {
    return GetField<float>(VT_LINE_SPEED, 0.0f);
  }
  float angular_velocity() const {
    return GetField<float>(VT_ANGULAR_VELOCITY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LINE_SPEED) &&
           VerifyField<float>(verifier, VT_ANGULAR_VELOCITY) &&
           verifier.EndTable();
  }
};

struct ClientReqSpeedBuilder {
  typedef ClientReqSpeed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_line_speed(float line_speed) {
    fbb_.AddElement<float>(ClientReqSpeed::VT_LINE_SPEED, line_speed, 0.0f);
  }
  void add_angular_velocity(float angular_velocity) {
    fbb_.AddElement<float>(ClientReqSpeed::VT_ANGULAR_VELOCITY, angular_velocity, 0.0f);
  }
  explicit ClientReqSpeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqSpeedBuilder &operator=(const ClientReqSpeedBuilder &);
  flatbuffers::Offset<ClientReqSpeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqSpeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqSpeed> CreateClientReqSpeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    float line_speed = 0.0f,
    float angular_velocity = 0.0f) {
  ClientReqSpeedBuilder builder_(_fbb);
  builder_.add_angular_velocity(angular_velocity);
  builder_.add_line_speed(line_speed);
  return builder_.Finish();
}

struct ClientReqStop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqStopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ClientReqStopBuilder {
  typedef ClientReqStop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqStop::VT_TIME, time, 0);
  }
  explicit ClientReqStopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqStopBuilder &operator=(const ClientReqStopBuilder &);
  flatbuffers::Offset<ClientReqStop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqStop>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqStop> CreateClientReqStop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  ClientReqStopBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ClientRptRemoteControl FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientRptRemoteControlBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  abby::KeyType key() const {
    return static_cast<abby::KeyType>(GetField<int8_t>(VT_KEY, 0));
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_KEY) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ClientRptRemoteControlBuilder {
  typedef ClientRptRemoteControl Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(abby::KeyType key) {
    fbb_.AddElement<int8_t>(ClientRptRemoteControl::VT_KEY, static_cast<int8_t>(key), 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(ClientRptRemoteControl::VT_VALUE, value, 0.0f);
  }
  explicit ClientRptRemoteControlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientRptRemoteControlBuilder &operator=(const ClientRptRemoteControlBuilder &);
  flatbuffers::Offset<ClientRptRemoteControl> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientRptRemoteControl>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientRptRemoteControl> CreateClientRptRemoteControl(
    flatbuffers::FlatBufferBuilder &_fbb,
    abby::KeyType key = abby::KeyType_up,
    float value = 0.0f) {
  ClientRptRemoteControlBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct ClientReqSwitchAuto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqSwitchAutoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ClientReqSwitchAutoBuilder {
  typedef ClientReqSwitchAuto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqSwitchAuto::VT_TIME, time, 0);
  }
  explicit ClientReqSwitchAutoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqSwitchAutoBuilder &operator=(const ClientReqSwitchAutoBuilder &);
  flatbuffers::Offset<ClientReqSwitchAuto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqSwitchAuto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqSwitchAuto> CreateClientReqSwitchAuto(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  ClientReqSwitchAutoBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ClientReqSwitchManual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqSwitchManualBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ClientReqSwitchManualBuilder {
  typedef ClientReqSwitchManual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqSwitchManual::VT_TIME, time, 0);
  }
  explicit ClientReqSwitchManualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqSwitchManualBuilder &operator=(const ClientReqSwitchManualBuilder &);
  flatbuffers::Offset<ClientReqSwitchManual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqSwitchManual>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqSwitchManual> CreateClientReqSwitchManual(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  ClientReqSwitchManualBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ClientReqAutoStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqAutoStartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_NEW_SCENE = 6,
    VT_SCENE_ID = 8,
    VT_MAP_ID = 10
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool new_scene() const {
    return GetField<uint8_t>(VT_NEW_SCENE, 0) != 0;
  }
  int64_t scene_id() const {
    return GetField<int64_t>(VT_SCENE_ID, 0);
  }
  int64_t map_id() const {
    return GetField<int64_t>(VT_MAP_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<uint8_t>(verifier, VT_NEW_SCENE) &&
           VerifyField<int64_t>(verifier, VT_SCENE_ID) &&
           VerifyField<int64_t>(verifier, VT_MAP_ID) &&
           verifier.EndTable();
  }
};

struct ClientReqAutoStartBuilder {
  typedef ClientReqAutoStart Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqAutoStart::VT_TIME, time, 0);
  }
  void add_new_scene(bool new_scene) {
    fbb_.AddElement<uint8_t>(ClientReqAutoStart::VT_NEW_SCENE, static_cast<uint8_t>(new_scene), 0);
  }
  void add_scene_id(int64_t scene_id) {
    fbb_.AddElement<int64_t>(ClientReqAutoStart::VT_SCENE_ID, scene_id, 0);
  }
  void add_map_id(int64_t map_id) {
    fbb_.AddElement<int64_t>(ClientReqAutoStart::VT_MAP_ID, map_id, 0);
  }
  explicit ClientReqAutoStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqAutoStartBuilder &operator=(const ClientReqAutoStartBuilder &);
  flatbuffers::Offset<ClientReqAutoStart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqAutoStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqAutoStart> CreateClientReqAutoStart(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    bool new_scene = false,
    int64_t scene_id = 0,
    int64_t map_id = 0) {
  ClientReqAutoStartBuilder builder_(_fbb);
  builder_.add_map_id(map_id);
  builder_.add_scene_id(scene_id);
  builder_.add_time(time);
  builder_.add_new_scene(new_scene);
  return builder_.Finish();
}

struct ClientReqMapList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqMapListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ClientReqMapListBuilder {
  typedef ClientReqMapList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqMapList::VT_TIME, time, 0);
  }
  explicit ClientReqMapListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqMapListBuilder &operator=(const ClientReqMapListBuilder &);
  flatbuffers::Offset<ClientReqMapList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqMapList>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqMapList> CreateClientReqMapList(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  ClientReqMapListBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ClientReqMapOccupancyGrid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqMapOccupancyGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URL = 4
  };
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           verifier.EndTable();
  }
};

struct ClientReqMapOccupancyGridBuilder {
  typedef ClientReqMapOccupancyGrid Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(ClientReqMapOccupancyGrid::VT_URL, url);
  }
  explicit ClientReqMapOccupancyGridBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqMapOccupancyGridBuilder &operator=(const ClientReqMapOccupancyGridBuilder &);
  flatbuffers::Offset<ClientReqMapOccupancyGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqMapOccupancyGrid>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqMapOccupancyGrid> CreateClientReqMapOccupancyGrid(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> url = 0) {
  ClientReqMapOccupancyGridBuilder builder_(_fbb);
  builder_.add_url(url);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientReqMapOccupancyGrid> CreateClientReqMapOccupancyGridDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *url = nullptr) {
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return abby::CreateClientReqMapOccupancyGrid(
      _fbb,
      url__);
}

struct ClientReqMapSemantics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqMapSemanticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCENE_ID = 4,
    VT_MAP_ID = 6
  };
  int64_t scene_id() const {
    return GetField<int64_t>(VT_SCENE_ID, 0);
  }
  int64_t map_id() const {
    return GetField<int64_t>(VT_MAP_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SCENE_ID) &&
           VerifyField<int64_t>(verifier, VT_MAP_ID) &&
           verifier.EndTable();
  }
};

struct ClientReqMapSemanticsBuilder {
  typedef ClientReqMapSemantics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scene_id(int64_t scene_id) {
    fbb_.AddElement<int64_t>(ClientReqMapSemantics::VT_SCENE_ID, scene_id, 0);
  }
  void add_map_id(int64_t map_id) {
    fbb_.AddElement<int64_t>(ClientReqMapSemantics::VT_MAP_ID, map_id, 0);
  }
  explicit ClientReqMapSemanticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqMapSemanticsBuilder &operator=(const ClientReqMapSemanticsBuilder &);
  flatbuffers::Offset<ClientReqMapSemantics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqMapSemantics>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqMapSemantics> CreateClientReqMapSemantics(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t scene_id = 0,
    int64_t map_id = 0) {
  ClientReqMapSemanticsBuilder builder_(_fbb);
  builder_.add_map_id(map_id);
  builder_.add_scene_id(scene_id);
  return builder_.Finish();
}

struct ClientReqStartRegion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqStartRegionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCENE_ID = 4,
    VT_MAP_ID = 6,
    VT_TYPE = 8,
    VT_AREAS = 10,
    VT_TIME = 12
  };
  int64_t scene_id() const {
    return GetField<int64_t>(VT_SCENE_ID, 0);
  }
  int64_t map_id() const {
    return GetField<int64_t>(VT_MAP_ID, 0);
  }
  abby::CleanType type() const {
    return static_cast<abby::CleanType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<abby::Area>> *areas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::Area>> *>(VT_AREAS);
  }
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SCENE_ID) &&
           VerifyField<int64_t>(verifier, VT_MAP_ID) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_AREAS) &&
           verifier.VerifyVector(areas()) &&
           verifier.VerifyVectorOfTables(areas()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ClientReqStartRegionBuilder {
  typedef ClientReqStartRegion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scene_id(int64_t scene_id) {
    fbb_.AddElement<int64_t>(ClientReqStartRegion::VT_SCENE_ID, scene_id, 0);
  }
  void add_map_id(int64_t map_id) {
    fbb_.AddElement<int64_t>(ClientReqStartRegion::VT_MAP_ID, map_id, 0);
  }
  void add_type(abby::CleanType type) {
    fbb_.AddElement<int8_t>(ClientReqStartRegion::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_areas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Area>>> areas) {
    fbb_.AddOffset(ClientReqStartRegion::VT_AREAS, areas);
  }
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqStartRegion::VT_TIME, time, 0);
  }
  explicit ClientReqStartRegionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqStartRegionBuilder &operator=(const ClientReqStartRegionBuilder &);
  flatbuffers::Offset<ClientReqStartRegion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqStartRegion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqStartRegion> CreateClientReqStartRegion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t scene_id = 0,
    int64_t map_id = 0,
    abby::CleanType type = abby::CleanType_CleanAll,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Area>>> areas = 0,
    int64_t time = 0) {
  ClientReqStartRegionBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_map_id(map_id);
  builder_.add_scene_id(scene_id);
  builder_.add_areas(areas);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientReqStartRegion> CreateClientReqStartRegionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t scene_id = 0,
    int64_t map_id = 0,
    abby::CleanType type = abby::CleanType_CleanAll,
    const std::vector<flatbuffers::Offset<abby::Area>> *areas = nullptr,
    int64_t time = 0) {
  auto areas__ = areas ? _fbb.CreateVector<flatbuffers::Offset<abby::Area>>(*areas) : 0;
  return abby::CreateClientReqStartRegion(
      _fbb,
      scene_id,
      map_id,
      type,
      areas__,
      time);
}

struct ClientReqSceneDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqSceneDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCENE_ID = 4,
    VT_MAP_ID = 6
  };
  int64_t scene_id() const {
    return GetField<int64_t>(VT_SCENE_ID, 0);
  }
  int64_t map_id() const {
    return GetField<int64_t>(VT_MAP_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SCENE_ID) &&
           VerifyField<int64_t>(verifier, VT_MAP_ID) &&
           verifier.EndTable();
  }
};

struct ClientReqSceneDescBuilder {
  typedef ClientReqSceneDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scene_id(int64_t scene_id) {
    fbb_.AddElement<int64_t>(ClientReqSceneDesc::VT_SCENE_ID, scene_id, 0);
  }
  void add_map_id(int64_t map_id) {
    fbb_.AddElement<int64_t>(ClientReqSceneDesc::VT_MAP_ID, map_id, 0);
  }
  explicit ClientReqSceneDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqSceneDescBuilder &operator=(const ClientReqSceneDescBuilder &);
  flatbuffers::Offset<ClientReqSceneDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqSceneDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqSceneDesc> CreateClientReqSceneDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t scene_id = 0,
    int64_t map_id = 0) {
  ClientReqSceneDescBuilder builder_(_fbb);
  builder_.add_map_id(map_id);
  builder_.add_scene_id(scene_id);
  return builder_.Finish();
}

struct ClientReqAddSceneDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqAddSceneDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESC = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<abby::Outline>> *desc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::Outline>> *>(VT_DESC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.VerifyVector(desc()) &&
           verifier.VerifyVectorOfTables(desc()) &&
           verifier.EndTable();
  }
};

struct ClientReqAddSceneDescBuilder {
  typedef ClientReqAddSceneDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_desc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Outline>>> desc) {
    fbb_.AddOffset(ClientReqAddSceneDesc::VT_DESC, desc);
  }
  explicit ClientReqAddSceneDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqAddSceneDescBuilder &operator=(const ClientReqAddSceneDescBuilder &);
  flatbuffers::Offset<ClientReqAddSceneDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqAddSceneDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqAddSceneDesc> CreateClientReqAddSceneDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Outline>>> desc = 0) {
  ClientReqAddSceneDescBuilder builder_(_fbb);
  builder_.add_desc(desc);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientReqAddSceneDesc> CreateClientReqAddSceneDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<abby::Outline>> *desc = nullptr) {
  auto desc__ = desc ? _fbb.CreateVector<flatbuffers::Offset<abby::Outline>>(*desc) : 0;
  return abby::CreateClientReqAddSceneDesc(
      _fbb,
      desc__);
}

struct ClientReqDelSceneDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqDelSceneDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDS = 4
  };
  const flatbuffers::Vector<int64_t> *ids() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDS) &&
           verifier.VerifyVector(ids()) &&
           verifier.EndTable();
  }
};

struct ClientReqDelSceneDescBuilder {
  typedef ClientReqDelSceneDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ids(flatbuffers::Offset<flatbuffers::Vector<int64_t>> ids) {
    fbb_.AddOffset(ClientReqDelSceneDesc::VT_IDS, ids);
  }
  explicit ClientReqDelSceneDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqDelSceneDescBuilder &operator=(const ClientReqDelSceneDescBuilder &);
  flatbuffers::Offset<ClientReqDelSceneDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqDelSceneDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqDelSceneDesc> CreateClientReqDelSceneDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> ids = 0) {
  ClientReqDelSceneDescBuilder builder_(_fbb);
  builder_.add_ids(ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientReqDelSceneDesc> CreateClientReqDelSceneDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *ids = nullptr) {
  auto ids__ = ids ? _fbb.CreateVector<int64_t>(*ids) : 0;
  return abby::CreateClientReqDelSceneDesc(
      _fbb,
      ids__);
}

struct ClientRequestSetState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientRequestSetStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  abby::CleanState state() const {
    return static_cast<abby::CleanState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct ClientRequestSetStateBuilder {
  typedef ClientRequestSetState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(abby::CleanState state) {
    fbb_.AddElement<int8_t>(ClientRequestSetState::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit ClientRequestSetStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientRequestSetStateBuilder &operator=(const ClientRequestSetStateBuilder &);
  flatbuffers::Offset<ClientRequestSetState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientRequestSetState>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientRequestSetState> CreateClientRequestSetState(
    flatbuffers::FlatBufferBuilder &_fbb,
    abby::CleanState state = abby::CleanState_Start) {
  ClientRequestSetStateBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct ClientReqRecharge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqRechargeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ClientReqRechargeBuilder {
  typedef ClientReqRecharge Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqRecharge::VT_TIME, time, 0);
  }
  explicit ClientReqRechargeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqRechargeBuilder &operator=(const ClientReqRechargeBuilder &);
  flatbuffers::Offset<ClientReqRecharge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqRecharge>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqRecharge> CreateClientReqRecharge(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  ClientReqRechargeBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ClientReqAddTimer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqAddTimerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK = 4
  };
  const abby::TimerTask *task() const {
    return GetPointer<const abby::TimerTask *>(VT_TASK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASK) &&
           verifier.VerifyTable(task()) &&
           verifier.EndTable();
  }
};

struct ClientReqAddTimerBuilder {
  typedef ClientReqAddTimer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_task(flatbuffers::Offset<abby::TimerTask> task) {
    fbb_.AddOffset(ClientReqAddTimer::VT_TASK, task);
  }
  explicit ClientReqAddTimerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqAddTimerBuilder &operator=(const ClientReqAddTimerBuilder &);
  flatbuffers::Offset<ClientReqAddTimer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqAddTimer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqAddTimer> CreateClientReqAddTimer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<abby::TimerTask> task = 0) {
  ClientReqAddTimerBuilder builder_(_fbb);
  builder_.add_task(task);
  return builder_.Finish();
}

struct ClientReqUpdateTimer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqUpdateTimerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK = 4
  };
  const abby::TimerTask *task() const {
    return GetPointer<const abby::TimerTask *>(VT_TASK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASK) &&
           verifier.VerifyTable(task()) &&
           verifier.EndTable();
  }
};

struct ClientReqUpdateTimerBuilder {
  typedef ClientReqUpdateTimer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_task(flatbuffers::Offset<abby::TimerTask> task) {
    fbb_.AddOffset(ClientReqUpdateTimer::VT_TASK, task);
  }
  explicit ClientReqUpdateTimerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqUpdateTimerBuilder &operator=(const ClientReqUpdateTimerBuilder &);
  flatbuffers::Offset<ClientReqUpdateTimer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqUpdateTimer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqUpdateTimer> CreateClientReqUpdateTimer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<abby::TimerTask> task = 0) {
  ClientReqUpdateTimerBuilder builder_(_fbb);
  builder_.add_task(task);
  return builder_.Finish();
}

struct ClientReqDelTimer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqDelTimerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK_ID = 4
  };
  int64_t task_id() const {
    return GetField<int64_t>(VT_TASK_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TASK_ID) &&
           verifier.EndTable();
  }
};

struct ClientReqDelTimerBuilder {
  typedef ClientReqDelTimer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_task_id(int64_t task_id) {
    fbb_.AddElement<int64_t>(ClientReqDelTimer::VT_TASK_ID, task_id, 0);
  }
  explicit ClientReqDelTimerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqDelTimerBuilder &operator=(const ClientReqDelTimerBuilder &);
  flatbuffers::Offset<ClientReqDelTimer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqDelTimer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqDelTimer> CreateClientReqDelTimer(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t task_id = 0) {
  ClientReqDelTimerBuilder builder_(_fbb);
  builder_.add_task_id(task_id);
  return builder_.Finish();
}

struct ClientReqListTimer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqListTimerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ClientReqListTimerBuilder {
  typedef ClientReqListTimer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqListTimer::VT_TIME, time, 0);
  }
  explicit ClientReqListTimerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqListTimerBuilder &operator=(const ClientReqListTimerBuilder &);
  flatbuffers::Offset<ClientReqListTimer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqListTimer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqListTimer> CreateClientReqListTimer(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  ClientReqListTimerBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ClientReqCleanMode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientReqCleanModeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CLEAN_MODE = 6
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  abby::CleanMode clean_mode() const {
    return static_cast<abby::CleanMode>(GetField<int8_t>(VT_CLEAN_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<int8_t>(verifier, VT_CLEAN_MODE) &&
           verifier.EndTable();
  }
};

struct ClientReqCleanModeBuilder {
  typedef ClientReqCleanMode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ClientReqCleanMode::VT_TIME, time, 0);
  }
  void add_clean_mode(abby::CleanMode clean_mode) {
    fbb_.AddElement<int8_t>(ClientReqCleanMode::VT_CLEAN_MODE, static_cast<int8_t>(clean_mode), 0);
  }
  explicit ClientReqCleanModeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientReqCleanModeBuilder &operator=(const ClientReqCleanModeBuilder &);
  flatbuffers::Offset<ClientReqCleanMode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientReqCleanMode>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientReqCleanMode> CreateClientReqCleanMode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    abby::CleanMode clean_mode = abby::CleanMode_Quiet) {
  ClientReqCleanModeBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_clean_mode(clean_mode);
  return builder_.Finish();
}

struct ClientData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  abby::ClientType message_type() const {
    return static_cast<abby::ClientType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const abby::ClientReqSn *message_as_ClientReqSn() const {
    return message_type() == abby::ClientType_ClientReqSn ? static_cast<const abby::ClientReqSn *>(message()) : nullptr;
  }
  const abby::ClientReqSpeed *message_as_ClientReqSpeed() const {
    return message_type() == abby::ClientType_ClientReqSpeed ? static_cast<const abby::ClientReqSpeed *>(message()) : nullptr;
  }
  const abby::ClientReqStop *message_as_ClientReqStop() const {
    return message_type() == abby::ClientType_ClientReqStop ? static_cast<const abby::ClientReqStop *>(message()) : nullptr;
  }
  const abby::ClientRptRemoteControl *message_as_ClientRptRemoteControl() const {
    return message_type() == abby::ClientType_ClientRptRemoteControl ? static_cast<const abby::ClientRptRemoteControl *>(message()) : nullptr;
  }
  const abby::ClientReqSwitchAuto *message_as_ClientReqSwitchAuto() const {
    return message_type() == abby::ClientType_ClientReqSwitchAuto ? static_cast<const abby::ClientReqSwitchAuto *>(message()) : nullptr;
  }
  const abby::ClientReqSwitchManual *message_as_ClientReqSwitchManual() const {
    return message_type() == abby::ClientType_ClientReqSwitchManual ? static_cast<const abby::ClientReqSwitchManual *>(message()) : nullptr;
  }
  const abby::ClientReqAutoStart *message_as_ClientReqAutoStart() const {
    return message_type() == abby::ClientType_ClientReqAutoStart ? static_cast<const abby::ClientReqAutoStart *>(message()) : nullptr;
  }
  const abby::ClientReqMapList *message_as_ClientReqMapList() const {
    return message_type() == abby::ClientType_ClientReqMapList ? static_cast<const abby::ClientReqMapList *>(message()) : nullptr;
  }
  const abby::ClientReqMapOccupancyGrid *message_as_ClientReqMapOccupancyGrid() const {
    return message_type() == abby::ClientType_ClientReqMapOccupancyGrid ? static_cast<const abby::ClientReqMapOccupancyGrid *>(message()) : nullptr;
  }
  const abby::ClientReqMapSemantics *message_as_ClientReqMapSemantics() const {
    return message_type() == abby::ClientType_ClientReqMapSemantics ? static_cast<const abby::ClientReqMapSemantics *>(message()) : nullptr;
  }
  const abby::ClientReqStartRegion *message_as_ClientReqStartRegion() const {
    return message_type() == abby::ClientType_ClientReqStartRegion ? static_cast<const abby::ClientReqStartRegion *>(message()) : nullptr;
  }
  const abby::ClientReqSceneDesc *message_as_ClientReqSceneDesc() const {
    return message_type() == abby::ClientType_ClientReqSceneDesc ? static_cast<const abby::ClientReqSceneDesc *>(message()) : nullptr;
  }
  const abby::ClientReqAddSceneDesc *message_as_ClientReqAddSceneDesc() const {
    return message_type() == abby::ClientType_ClientReqAddSceneDesc ? static_cast<const abby::ClientReqAddSceneDesc *>(message()) : nullptr;
  }
  const abby::ClientReqDelSceneDesc *message_as_ClientReqDelSceneDesc() const {
    return message_type() == abby::ClientType_ClientReqDelSceneDesc ? static_cast<const abby::ClientReqDelSceneDesc *>(message()) : nullptr;
  }
  const abby::ClientRequestSetState *message_as_ClientRequestSetState() const {
    return message_type() == abby::ClientType_ClientRequestSetState ? static_cast<const abby::ClientRequestSetState *>(message()) : nullptr;
  }
  const abby::ClientReqRecharge *message_as_ClientReqRecharge() const {
    return message_type() == abby::ClientType_ClientReqRecharge ? static_cast<const abby::ClientReqRecharge *>(message()) : nullptr;
  }
  const abby::ClientReqAddTimer *message_as_ClientReqAddTimer() const {
    return message_type() == abby::ClientType_ClientReqAddTimer ? static_cast<const abby::ClientReqAddTimer *>(message()) : nullptr;
  }
  const abby::ClientReqUpdateTimer *message_as_ClientReqUpdateTimer() const {
    return message_type() == abby::ClientType_ClientReqUpdateTimer ? static_cast<const abby::ClientReqUpdateTimer *>(message()) : nullptr;
  }
  const abby::ClientReqDelTimer *message_as_ClientReqDelTimer() const {
    return message_type() == abby::ClientType_ClientReqDelTimer ? static_cast<const abby::ClientReqDelTimer *>(message()) : nullptr;
  }
  const abby::ClientReqListTimer *message_as_ClientReqListTimer() const {
    return message_type() == abby::ClientType_ClientReqListTimer ? static_cast<const abby::ClientReqListTimer *>(message()) : nullptr;
  }
  const abby::ClientReqCleanMode *message_as_ClientReqCleanMode() const {
    return message_type() == abby::ClientType_ClientReqCleanMode ? static_cast<const abby::ClientReqCleanMode *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyClientType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const abby::ClientReqSn *ClientData::message_as<abby::ClientReqSn>() const {
  return message_as_ClientReqSn();
}

template<> inline const abby::ClientReqSpeed *ClientData::message_as<abby::ClientReqSpeed>() const {
  return message_as_ClientReqSpeed();
}

template<> inline const abby::ClientReqStop *ClientData::message_as<abby::ClientReqStop>() const {
  return message_as_ClientReqStop();
}

template<> inline const abby::ClientRptRemoteControl *ClientData::message_as<abby::ClientRptRemoteControl>() const {
  return message_as_ClientRptRemoteControl();
}

template<> inline const abby::ClientReqSwitchAuto *ClientData::message_as<abby::ClientReqSwitchAuto>() const {
  return message_as_ClientReqSwitchAuto();
}

template<> inline const abby::ClientReqSwitchManual *ClientData::message_as<abby::ClientReqSwitchManual>() const {
  return message_as_ClientReqSwitchManual();
}

template<> inline const abby::ClientReqAutoStart *ClientData::message_as<abby::ClientReqAutoStart>() const {
  return message_as_ClientReqAutoStart();
}

template<> inline const abby::ClientReqMapList *ClientData::message_as<abby::ClientReqMapList>() const {
  return message_as_ClientReqMapList();
}

template<> inline const abby::ClientReqMapOccupancyGrid *ClientData::message_as<abby::ClientReqMapOccupancyGrid>() const {
  return message_as_ClientReqMapOccupancyGrid();
}

template<> inline const abby::ClientReqMapSemantics *ClientData::message_as<abby::ClientReqMapSemantics>() const {
  return message_as_ClientReqMapSemantics();
}

template<> inline const abby::ClientReqStartRegion *ClientData::message_as<abby::ClientReqStartRegion>() const {
  return message_as_ClientReqStartRegion();
}

template<> inline const abby::ClientReqSceneDesc *ClientData::message_as<abby::ClientReqSceneDesc>() const {
  return message_as_ClientReqSceneDesc();
}

template<> inline const abby::ClientReqAddSceneDesc *ClientData::message_as<abby::ClientReqAddSceneDesc>() const {
  return message_as_ClientReqAddSceneDesc();
}

template<> inline const abby::ClientReqDelSceneDesc *ClientData::message_as<abby::ClientReqDelSceneDesc>() const {
  return message_as_ClientReqDelSceneDesc();
}

template<> inline const abby::ClientRequestSetState *ClientData::message_as<abby::ClientRequestSetState>() const {
  return message_as_ClientRequestSetState();
}

template<> inline const abby::ClientReqRecharge *ClientData::message_as<abby::ClientReqRecharge>() const {
  return message_as_ClientReqRecharge();
}

template<> inline const abby::ClientReqAddTimer *ClientData::message_as<abby::ClientReqAddTimer>() const {
  return message_as_ClientReqAddTimer();
}

template<> inline const abby::ClientReqUpdateTimer *ClientData::message_as<abby::ClientReqUpdateTimer>() const {
  return message_as_ClientReqUpdateTimer();
}

template<> inline const abby::ClientReqDelTimer *ClientData::message_as<abby::ClientReqDelTimer>() const {
  return message_as_ClientReqDelTimer();
}

template<> inline const abby::ClientReqListTimer *ClientData::message_as<abby::ClientReqListTimer>() const {
  return message_as_ClientReqListTimer();
}

template<> inline const abby::ClientReqCleanMode *ClientData::message_as<abby::ClientReqCleanMode>() const {
  return message_as_ClientReqCleanMode();
}

struct ClientDataBuilder {
  typedef ClientData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(abby::ClientType message_type) {
    fbb_.AddElement<uint8_t>(ClientData::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(ClientData::VT_MESSAGE, message);
  }
  explicit ClientDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientDataBuilder &operator=(const ClientDataBuilder &);
  flatbuffers::Offset<ClientData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientData> CreateClientData(
    flatbuffers::FlatBufferBuilder &_fbb,
    abby::ClientType message_type = abby::ClientType_NONE,
    flatbuffers::Offset<void> message = 0) {
  ClientDataBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyClientType(flatbuffers::Verifier &verifier, const void *obj, ClientType type) {
  switch (type) {
    case ClientType_NONE: {
      return true;
    }
    case ClientType_ClientReqSn: {
      auto ptr = reinterpret_cast<const abby::ClientReqSn *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqSpeed: {
      auto ptr = reinterpret_cast<const abby::ClientReqSpeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqStop: {
      auto ptr = reinterpret_cast<const abby::ClientReqStop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientRptRemoteControl: {
      auto ptr = reinterpret_cast<const abby::ClientRptRemoteControl *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqSwitchAuto: {
      auto ptr = reinterpret_cast<const abby::ClientReqSwitchAuto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqSwitchManual: {
      auto ptr = reinterpret_cast<const abby::ClientReqSwitchManual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqAutoStart: {
      auto ptr = reinterpret_cast<const abby::ClientReqAutoStart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqMapList: {
      auto ptr = reinterpret_cast<const abby::ClientReqMapList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqMapOccupancyGrid: {
      auto ptr = reinterpret_cast<const abby::ClientReqMapOccupancyGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqMapSemantics: {
      auto ptr = reinterpret_cast<const abby::ClientReqMapSemantics *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqStartRegion: {
      auto ptr = reinterpret_cast<const abby::ClientReqStartRegion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqSceneDesc: {
      auto ptr = reinterpret_cast<const abby::ClientReqSceneDesc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqAddSceneDesc: {
      auto ptr = reinterpret_cast<const abby::ClientReqAddSceneDesc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqDelSceneDesc: {
      auto ptr = reinterpret_cast<const abby::ClientReqDelSceneDesc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientRequestSetState: {
      auto ptr = reinterpret_cast<const abby::ClientRequestSetState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqRecharge: {
      auto ptr = reinterpret_cast<const abby::ClientReqRecharge *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqAddTimer: {
      auto ptr = reinterpret_cast<const abby::ClientReqAddTimer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqUpdateTimer: {
      auto ptr = reinterpret_cast<const abby::ClientReqUpdateTimer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqDelTimer: {
      auto ptr = reinterpret_cast<const abby::ClientReqDelTimer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqListTimer: {
      auto ptr = reinterpret_cast<const abby::ClientReqListTimer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClientType_ClientReqCleanMode: {
      auto ptr = reinterpret_cast<const abby::ClientReqCleanMode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyClientTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyClientType(
        verifier,  values->Get(i), types->GetEnum<ClientType>(i))) {
      return false;
    }
  }
  return true;
}

inline const abby::ClientData *GetClientData(const void *buf) {
  return flatbuffers::GetRoot<abby::ClientData>(buf);
}

inline const abby::ClientData *GetSizePrefixedClientData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<abby::ClientData>(buf);
}

inline bool VerifyClientDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<abby::ClientData>(nullptr);
}

inline bool VerifySizePrefixedClientDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<abby::ClientData>(nullptr);
}

inline void FinishClientDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<abby::ClientData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedClientDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<abby::ClientData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace abby

#endif  // FLATBUFFERS_GENERATED_C2S_ABBY_H_
