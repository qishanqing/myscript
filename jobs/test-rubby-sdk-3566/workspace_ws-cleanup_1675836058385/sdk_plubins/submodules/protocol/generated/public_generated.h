// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PUBLIC_ABBY_H_
#define FLATBUFFERS_GENERATED_PUBLIC_ABBY_H_

#include "flatbuffers/flatbuffers.h"

namespace abby {

struct MapInfo;
struct MapInfoBuilder;

struct Point2D;
struct Point2DBuilder;

struct Area;
struct AreaBuilder;

struct Outline;
struct OutlineBuilder;

struct TimerTask;
struct TimerTaskBuilder;

enum CleanType {
  CleanType_CleanAll = 0,
  CleanType_CleanPartition = 1,
  CleanType_CleanRegion = 2,
  CleanType_CleanSemantics = 3,
  CleanType_MIN = CleanType_CleanAll,
  CleanType_MAX = CleanType_CleanSemantics
};

inline const CleanType (&EnumValuesCleanType())[4] {
  static const CleanType values[] = {
    CleanType_CleanAll,
    CleanType_CleanPartition,
    CleanType_CleanRegion,
    CleanType_CleanSemantics
  };
  return values;
}

inline const char * const *EnumNamesCleanType() {
  static const char * const names[5] = {
    "CleanAll",
    "CleanPartition",
    "CleanRegion",
    "CleanSemantics",
    nullptr
  };
  return names;
}

inline const char *EnumNameCleanType(CleanType e) {
  if (flatbuffers::IsOutRange(e, CleanType_CleanAll, CleanType_CleanSemantics)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCleanType()[index];
}

enum OutlineType {
  OutlineType_WholeRegion = 0,
  OutlineType_Partition = 1,
  OutlineType_Region = 2,
  OutlineType_Semantics = 3,
  OutlineType_ForbiddenZone = 4,
  OutlineType_VirtualWall = 5,
  OutlineType_ChargingPile = 6,
  OutlineType_MIN = OutlineType_WholeRegion,
  OutlineType_MAX = OutlineType_ChargingPile
};

inline const OutlineType (&EnumValuesOutlineType())[7] {
  static const OutlineType values[] = {
    OutlineType_WholeRegion,
    OutlineType_Partition,
    OutlineType_Region,
    OutlineType_Semantics,
    OutlineType_ForbiddenZone,
    OutlineType_VirtualWall,
    OutlineType_ChargingPile
  };
  return values;
}

inline const char * const *EnumNamesOutlineType() {
  static const char * const names[8] = {
    "WholeRegion",
    "Partition",
    "Region",
    "Semantics",
    "ForbiddenZone",
    "VirtualWall",
    "ChargingPile",
    nullptr
  };
  return names;
}

inline const char *EnumNameOutlineType(OutlineType e) {
  if (flatbuffers::IsOutRange(e, OutlineType_WholeRegion, OutlineType_ChargingPile)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOutlineType()[index];
}

enum CleanState {
  CleanState_Start = 0,
  CleanState_Pause = 1,
  CleanState_Continue = 2,
  CleanState_Stop = 3,
  CleanState_MIN = CleanState_Start,
  CleanState_MAX = CleanState_Stop
};

inline const CleanState (&EnumValuesCleanState())[4] {
  static const CleanState values[] = {
    CleanState_Start,
    CleanState_Pause,
    CleanState_Continue,
    CleanState_Stop
  };
  return values;
}

inline const char * const *EnumNamesCleanState() {
  static const char * const names[5] = {
    "Start",
    "Pause",
    "Continue",
    "Stop",
    nullptr
  };
  return names;
}

inline const char *EnumNameCleanState(CleanState e) {
  if (flatbuffers::IsOutRange(e, CleanState_Start, CleanState_Stop)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCleanState()[index];
}

enum FinishStatus {
  FinishStatus_OK = 0,
  FinishStatus_ERROR = 1,
  FinishStatus_MIN = FinishStatus_OK,
  FinishStatus_MAX = FinishStatus_ERROR
};

inline const FinishStatus (&EnumValuesFinishStatus())[2] {
  static const FinishStatus values[] = {
    FinishStatus_OK,
    FinishStatus_ERROR
  };
  return values;
}

inline const char * const *EnumNamesFinishStatus() {
  static const char * const names[3] = {
    "OK",
    "ERROR",
    nullptr
  };
  return names;
}

inline const char *EnumNameFinishStatus(FinishStatus e) {
  if (flatbuffers::IsOutRange(e, FinishStatus_OK, FinishStatus_ERROR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFinishStatus()[index];
}

enum CleanMode {
  CleanMode_Quiet = 0,
  CleanMode_FullPower = 1,
  CleanMode_MIN = CleanMode_Quiet,
  CleanMode_MAX = CleanMode_FullPower
};

inline const CleanMode (&EnumValuesCleanMode())[2] {
  static const CleanMode values[] = {
    CleanMode_Quiet,
    CleanMode_FullPower
  };
  return values;
}

inline const char * const *EnumNamesCleanMode() {
  static const char * const names[3] = {
    "Quiet",
    "FullPower",
    nullptr
  };
  return names;
}

inline const char *EnumNameCleanMode(CleanMode e) {
  if (flatbuffers::IsOutRange(e, CleanMode_Quiet, CleanMode_FullPower)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCleanMode()[index];
}

enum SportMode {
  SportMode_NewMap = 0,
  SportMode_UseMap = 1,
  SportMode_P2P = 2,
  SportMode_MIN = SportMode_NewMap,
  SportMode_MAX = SportMode_P2P
};

inline const SportMode (&EnumValuesSportMode())[3] {
  static const SportMode values[] = {
    SportMode_NewMap,
    SportMode_UseMap,
    SportMode_P2P
  };
  return values;
}

inline const char * const *EnumNamesSportMode() {
  static const char * const names[4] = {
    "NewMap",
    "UseMap",
    "P2P",
    nullptr
  };
  return names;
}

inline const char *EnumNameSportMode(SportMode e) {
  if (flatbuffers::IsOutRange(e, SportMode_NewMap, SportMode_P2P)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSportMode()[index];
}

enum TimerDuration {
  TimerDuration_Once = 1,
  TimerDuration_Everyday = 2,
  TimerDuration_Weekday = 3,
  TimerDuration_Weekend = 4,
  TimerDuration_Monday = 5,
  TimerDuration_Tuesday = 6,
  TimerDuration_Wednesday = 7,
  TimerDuration_Thursday = 8,
  TimerDuration_Friday = 9,
  TimerDuration_Saturday = 10,
  TimerDuration_Sunday = 11,
  TimerDuration_MIN = TimerDuration_Once,
  TimerDuration_MAX = TimerDuration_Sunday
};

inline const TimerDuration (&EnumValuesTimerDuration())[11] {
  static const TimerDuration values[] = {
    TimerDuration_Once,
    TimerDuration_Everyday,
    TimerDuration_Weekday,
    TimerDuration_Weekend,
    TimerDuration_Monday,
    TimerDuration_Tuesday,
    TimerDuration_Wednesday,
    TimerDuration_Thursday,
    TimerDuration_Friday,
    TimerDuration_Saturday,
    TimerDuration_Sunday
  };
  return values;
}

inline const char * const *EnumNamesTimerDuration() {
  static const char * const names[12] = {
    "Once",
    "Everyday",
    "Weekday",
    "Weekend",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimerDuration(TimerDuration e) {
  if (flatbuffers::IsOutRange(e, TimerDuration_Once, TimerDuration_Sunday)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(TimerDuration_Once);
  return EnumNamesTimerDuration()[index];
}

struct MapInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SCENE_ID = 6,
    VT_MAP_ID = 8,
    VT_USE_COUNT = 10,
    VT_IMAGE = 12,
    VT_THUMBNAIL = 14,
    VT_DATE = 16,
    VT_LAST_DATA = 18,
    VT_DEFAULT_ = 20
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int64_t scene_id() const {
    return GetField<int64_t>(VT_SCENE_ID, 0);
  }
  int64_t map_id() const {
    return GetField<int64_t>(VT_MAP_ID, 0);
  }
  int32_t use_count() const {
    return GetField<int32_t>(VT_USE_COUNT, 0);
  }
  const flatbuffers::String *image() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGE);
  }
  const flatbuffers::String *thumbnail() const {
    return GetPointer<const flatbuffers::String *>(VT_THUMBNAIL);
  }
  int64_t date() const {
    return GetField<int64_t>(VT_DATE, 0);
  }
  int64_t last_data() const {
    return GetField<int64_t>(VT_LAST_DATA, 0);
  }
  bool default_() const {
    return GetField<uint8_t>(VT_DEFAULT_, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyField<int64_t>(verifier, VT_SCENE_ID) &&
           VerifyField<int64_t>(verifier, VT_MAP_ID) &&
           VerifyField<int32_t>(verifier, VT_USE_COUNT) &&
           VerifyOffset(verifier, VT_IMAGE) &&
           verifier.VerifyString(image()) &&
           VerifyOffset(verifier, VT_THUMBNAIL) &&
           verifier.VerifyString(thumbnail()) &&
           VerifyField<int64_t>(verifier, VT_DATE) &&
           VerifyField<int64_t>(verifier, VT_LAST_DATA) &&
           VerifyField<uint8_t>(verifier, VT_DEFAULT_) &&
           verifier.EndTable();
  }
};

struct MapInfoBuilder {
  typedef MapInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(MapInfo::VT_ID, id, 0);
  }
  void add_scene_id(int64_t scene_id) {
    fbb_.AddElement<int64_t>(MapInfo::VT_SCENE_ID, scene_id, 0);
  }
  void add_map_id(int64_t map_id) {
    fbb_.AddElement<int64_t>(MapInfo::VT_MAP_ID, map_id, 0);
  }
  void add_use_count(int32_t use_count) {
    fbb_.AddElement<int32_t>(MapInfo::VT_USE_COUNT, use_count, 0);
  }
  void add_image(flatbuffers::Offset<flatbuffers::String> image) {
    fbb_.AddOffset(MapInfo::VT_IMAGE, image);
  }
  void add_thumbnail(flatbuffers::Offset<flatbuffers::String> thumbnail) {
    fbb_.AddOffset(MapInfo::VT_THUMBNAIL, thumbnail);
  }
  void add_date(int64_t date) {
    fbb_.AddElement<int64_t>(MapInfo::VT_DATE, date, 0);
  }
  void add_last_data(int64_t last_data) {
    fbb_.AddElement<int64_t>(MapInfo::VT_LAST_DATA, last_data, 0);
  }
  void add_default_(bool default_) {
    fbb_.AddElement<uint8_t>(MapInfo::VT_DEFAULT_, static_cast<uint8_t>(default_), 0);
  }
  explicit MapInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapInfoBuilder &operator=(const MapInfoBuilder &);
  flatbuffers::Offset<MapInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapInfo> CreateMapInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int64_t scene_id = 0,
    int64_t map_id = 0,
    int32_t use_count = 0,
    flatbuffers::Offset<flatbuffers::String> image = 0,
    flatbuffers::Offset<flatbuffers::String> thumbnail = 0,
    int64_t date = 0,
    int64_t last_data = 0,
    bool default_ = false) {
  MapInfoBuilder builder_(_fbb);
  builder_.add_last_data(last_data);
  builder_.add_date(date);
  builder_.add_map_id(map_id);
  builder_.add_scene_id(scene_id);
  builder_.add_id(id);
  builder_.add_thumbnail(thumbnail);
  builder_.add_image(image);
  builder_.add_use_count(use_count);
  builder_.add_default_(default_);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapInfo> CreateMapInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int64_t scene_id = 0,
    int64_t map_id = 0,
    int32_t use_count = 0,
    const char *image = nullptr,
    const char *thumbnail = nullptr,
    int64_t date = 0,
    int64_t last_data = 0,
    bool default_ = false) {
  auto image__ = image ? _fbb.CreateString(image) : 0;
  auto thumbnail__ = thumbnail ? _fbb.CreateString(thumbnail) : 0;
  return abby::CreateMapInfo(
      _fbb,
      id,
      scene_id,
      map_id,
      use_count,
      image__,
      thumbnail__,
      date,
      last_data,
      default_);
}

struct Point2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Point2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct Point2DBuilder {
  typedef Point2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Point2D::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Point2D::VT_Y, y, 0.0);
  }
  explicit Point2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Point2DBuilder &operator=(const Point2DBuilder &);
  flatbuffers::Offset<Point2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Point2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Point2D> CreatePoint2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0) {
  Point2DBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Area FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AreaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<abby::Point2D>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::Point2D>> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           verifier.EndTable();
  }
};

struct AreaBuilder {
  typedef Area Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Point2D>>> points) {
    fbb_.AddOffset(Area::VT_POINTS, points);
  }
  explicit AreaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AreaBuilder &operator=(const AreaBuilder &);
  flatbuffers::Offset<Area> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Area>(end);
    return o;
  }
};

inline flatbuffers::Offset<Area> CreateArea(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Point2D>>> points = 0) {
  AreaBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline flatbuffers::Offset<Area> CreateAreaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<abby::Point2D>> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVector<flatbuffers::Offset<abby::Point2D>>(*points) : 0;
  return abby::CreateArea(
      _fbb,
      points__);
}

struct Outline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutlineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SCENE_ID = 6,
    VT_MAP_ID = 8,
    VT_TYPE = 10,
    VT_AREAS = 12
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int64_t scene_id() const {
    return GetField<int64_t>(VT_SCENE_ID, 0);
  }
  int64_t map_id() const {
    return GetField<int64_t>(VT_MAP_ID, 0);
  }
  abby::OutlineType type() const {
    return static_cast<abby::OutlineType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<abby::Area>> *areas() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::Area>> *>(VT_AREAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyField<int64_t>(verifier, VT_SCENE_ID) &&
           VerifyField<int64_t>(verifier, VT_MAP_ID) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_AREAS) &&
           verifier.VerifyVector(areas()) &&
           verifier.VerifyVectorOfTables(areas()) &&
           verifier.EndTable();
  }
};

struct OutlineBuilder {
  typedef Outline Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(Outline::VT_ID, id, 0);
  }
  void add_scene_id(int64_t scene_id) {
    fbb_.AddElement<int64_t>(Outline::VT_SCENE_ID, scene_id, 0);
  }
  void add_map_id(int64_t map_id) {
    fbb_.AddElement<int64_t>(Outline::VT_MAP_ID, map_id, 0);
  }
  void add_type(abby::OutlineType type) {
    fbb_.AddElement<int8_t>(Outline::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_areas(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Area>>> areas) {
    fbb_.AddOffset(Outline::VT_AREAS, areas);
  }
  explicit OutlineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OutlineBuilder &operator=(const OutlineBuilder &);
  flatbuffers::Offset<Outline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Outline>(end);
    return o;
  }
};

inline flatbuffers::Offset<Outline> CreateOutline(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int64_t scene_id = 0,
    int64_t map_id = 0,
    abby::OutlineType type = abby::OutlineType_WholeRegion,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Area>>> areas = 0) {
  OutlineBuilder builder_(_fbb);
  builder_.add_map_id(map_id);
  builder_.add_scene_id(scene_id);
  builder_.add_id(id);
  builder_.add_areas(areas);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Outline> CreateOutlineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int64_t scene_id = 0,
    int64_t map_id = 0,
    abby::OutlineType type = abby::OutlineType_WholeRegion,
    const std::vector<flatbuffers::Offset<abby::Area>> *areas = nullptr) {
  auto areas__ = areas ? _fbb.CreateVector<flatbuffers::Offset<abby::Area>>(*areas) : 0;
  return abby::CreateOutline(
      _fbb,
      id,
      scene_id,
      map_id,
      type,
      areas__);
}

struct TimerTask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimerTaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TASK_NAME = 6,
    VT_SCENE_ID = 8,
    VT_MAP_ID = 10,
    VT_AREA_ID = 12,
    VT_CLEAN_MODE = 14,
    VT_DURATION = 16,
    VT_TASK_START_TIME = 18
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  const flatbuffers::String *task_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TASK_NAME);
  }
  int64_t scene_id() const {
    return GetField<int64_t>(VT_SCENE_ID, 0);
  }
  int64_t map_id() const {
    return GetField<int64_t>(VT_MAP_ID, 0);
  }
  int64_t area_id() const {
    return GetField<int64_t>(VT_AREA_ID, 0);
  }
  abby::CleanMode clean_mode() const {
    return static_cast<abby::CleanMode>(GetField<int8_t>(VT_CLEAN_MODE, 0));
  }
  int8_t duration() const {
    return GetField<int8_t>(VT_DURATION, 0);
  }
  const flatbuffers::String *task_start_time() const {
    return GetPointer<const flatbuffers::String *>(VT_TASK_START_TIME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_TASK_NAME) &&
           verifier.VerifyString(task_name()) &&
           VerifyField<int64_t>(verifier, VT_SCENE_ID) &&
           VerifyField<int64_t>(verifier, VT_MAP_ID) &&
           VerifyField<int64_t>(verifier, VT_AREA_ID) &&
           VerifyField<int8_t>(verifier, VT_CLEAN_MODE) &&
           VerifyField<int8_t>(verifier, VT_DURATION) &&
           VerifyOffset(verifier, VT_TASK_START_TIME) &&
           verifier.VerifyString(task_start_time()) &&
           verifier.EndTable();
  }
};

struct TimerTaskBuilder {
  typedef TimerTask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(TimerTask::VT_ID, id, 0);
  }
  void add_task_name(flatbuffers::Offset<flatbuffers::String> task_name) {
    fbb_.AddOffset(TimerTask::VT_TASK_NAME, task_name);
  }
  void add_scene_id(int64_t scene_id) {
    fbb_.AddElement<int64_t>(TimerTask::VT_SCENE_ID, scene_id, 0);
  }
  void add_map_id(int64_t map_id) {
    fbb_.AddElement<int64_t>(TimerTask::VT_MAP_ID, map_id, 0);
  }
  void add_area_id(int64_t area_id) {
    fbb_.AddElement<int64_t>(TimerTask::VT_AREA_ID, area_id, 0);
  }
  void add_clean_mode(abby::CleanMode clean_mode) {
    fbb_.AddElement<int8_t>(TimerTask::VT_CLEAN_MODE, static_cast<int8_t>(clean_mode), 0);
  }
  void add_duration(int8_t duration) {
    fbb_.AddElement<int8_t>(TimerTask::VT_DURATION, duration, 0);
  }
  void add_task_start_time(flatbuffers::Offset<flatbuffers::String> task_start_time) {
    fbb_.AddOffset(TimerTask::VT_TASK_START_TIME, task_start_time);
  }
  explicit TimerTaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimerTaskBuilder &operator=(const TimerTaskBuilder &);
  flatbuffers::Offset<TimerTask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimerTask>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimerTask> CreateTimerTask(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    flatbuffers::Offset<flatbuffers::String> task_name = 0,
    int64_t scene_id = 0,
    int64_t map_id = 0,
    int64_t area_id = 0,
    abby::CleanMode clean_mode = abby::CleanMode_Quiet,
    int8_t duration = 0,
    flatbuffers::Offset<flatbuffers::String> task_start_time = 0) {
  TimerTaskBuilder builder_(_fbb);
  builder_.add_area_id(area_id);
  builder_.add_map_id(map_id);
  builder_.add_scene_id(scene_id);
  builder_.add_id(id);
  builder_.add_task_start_time(task_start_time);
  builder_.add_task_name(task_name);
  builder_.add_duration(duration);
  builder_.add_clean_mode(clean_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<TimerTask> CreateTimerTaskDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    const char *task_name = nullptr,
    int64_t scene_id = 0,
    int64_t map_id = 0,
    int64_t area_id = 0,
    abby::CleanMode clean_mode = abby::CleanMode_Quiet,
    int8_t duration = 0,
    const char *task_start_time = nullptr) {
  auto task_name__ = task_name ? _fbb.CreateString(task_name) : 0;
  auto task_start_time__ = task_start_time ? _fbb.CreateString(task_start_time) : 0;
  return abby::CreateTimerTask(
      _fbb,
      id,
      task_name__,
      scene_id,
      map_id,
      area_id,
      clean_mode,
      duration,
      task_start_time__);
}

}  // namespace abby

#endif  // FLATBUFFERS_GENERATED_PUBLIC_ABBY_H_
