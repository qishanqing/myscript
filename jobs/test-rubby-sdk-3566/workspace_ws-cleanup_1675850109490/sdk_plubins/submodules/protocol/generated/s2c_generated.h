// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_S2C_ABBY_H_
#define FLATBUFFERS_GENERATED_S2C_ABBY_H_

#include "flatbuffers/flatbuffers.h"

#include "public_generated.h"

namespace abby {

struct ServerRptImage;
struct ServerRptImageBuilder;

struct ServerGrid;
struct ServerGridBuilder;

struct ServerRptOccupancyGrid;
struct ServerRptOccupancyGridBuilder;

struct ServerRespSn;
struct ServerRespSnBuilder;

struct ServerRptWorkingState;
struct ServerRptWorkingStateBuilder;

struct ServerRespSpeed;
struct ServerRespSpeedBuilder;

struct ServerRespStop;
struct ServerRespStopBuilder;

struct ServerRptPose;
struct ServerRptPoseBuilder;

struct ServerRespSwitchAuto;
struct ServerRespSwitchAutoBuilder;

struct ServerRespSwitchManual;
struct ServerRespSwitchManualBuilder;

struct ServerRespAutoStart;
struct ServerRespAutoStartBuilder;

struct Point;
struct PointBuilder;

struct ServerSenmaticObject;
struct ServerSenmaticObjectBuilder;

struct ServerRptSenmaticMap;
struct ServerRptSenmaticMapBuilder;

struct ServerRespMapList;
struct ServerRespMapListBuilder;

struct ServerRespMapOccupancyGrid;
struct ServerRespMapOccupancyGridBuilder;

struct ServerRespMapSemantics;
struct ServerRespMapSemanticsBuilder;

struct ServerRespStartRegion;
struct ServerRespStartRegionBuilder;

struct ServerRespSceneDesc;
struct ServerRespSceneDescBuilder;

struct ServerRespAddSceneDesc;
struct ServerRespAddSceneDescBuilder;

struct ServerRespDelSceneDesc;
struct ServerRespDelSceneDescBuilder;

struct ServerRespSetState;
struct ServerRespSetStateBuilder;

struct ServerRptChangeMap;
struct ServerRptChangeMapBuilder;

struct ServerRptRelocationFailed;
struct ServerRptRelocationFailedBuilder;

struct ServerRptFinishStatus;
struct ServerRptFinishStatusBuilder;

struct ServerRespRecharge;
struct ServerRespRechargeBuilder;

struct ServerRespAddTimer;
struct ServerRespAddTimerBuilder;

struct ServerRespUpdateTimer;
struct ServerRespUpdateTimerBuilder;

struct ServerRespDelTimer;
struct ServerRespDelTimerBuilder;

struct ServerRespListTimer;
struct ServerRespListTimerBuilder;

struct ServerData;
struct ServerDataBuilder;

enum WorkingType {
  WorkingType_Ready = 0,
  WorkingType_Cleaning = 1,
  WorkingType_RemoteControl = 2,
  WorkingType_Fault = 3,
  WorkingType_CleanRegion = 4,
  WorkingType_MIN = WorkingType_Ready,
  WorkingType_MAX = WorkingType_CleanRegion
};

inline const WorkingType (&EnumValuesWorkingType())[5] {
  static const WorkingType values[] = {
    WorkingType_Ready,
    WorkingType_Cleaning,
    WorkingType_RemoteControl,
    WorkingType_Fault,
    WorkingType_CleanRegion
  };
  return values;
}

inline const char * const *EnumNamesWorkingType() {
  static const char * const names[6] = {
    "Ready",
    "Cleaning",
    "RemoteControl",
    "Fault",
    "CleanRegion",
    nullptr
  };
  return names;
}

inline const char *EnumNameWorkingType(WorkingType e) {
  if (flatbuffers::IsOutRange(e, WorkingType_Ready, WorkingType_CleanRegion)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWorkingType()[index];
}

enum ClassID {
  ClassID_UNKNOWN = 0,
  ClassID_SHOES = 1,
  ClassID_BIN = 2,
  ClassID_PEDESTAL = 3,
  ClassID_WIRE = 4,
  ClassID_SOCKET = 5,
  ClassID_CAT = 6,
  ClassID_DOG = 7,
  ClassID_DESK_RECT = 8,
  ClassID_DESK_CIRCLE = 9,
  ClassID_MIN = ClassID_UNKNOWN,
  ClassID_MAX = ClassID_DESK_CIRCLE
};

inline const ClassID (&EnumValuesClassID())[10] {
  static const ClassID values[] = {
    ClassID_UNKNOWN,
    ClassID_SHOES,
    ClassID_BIN,
    ClassID_PEDESTAL,
    ClassID_WIRE,
    ClassID_SOCKET,
    ClassID_CAT,
    ClassID_DOG,
    ClassID_DESK_RECT,
    ClassID_DESK_CIRCLE
  };
  return values;
}

inline const char * const *EnumNamesClassID() {
  static const char * const names[11] = {
    "UNKNOWN",
    "SHOES",
    "BIN",
    "PEDESTAL",
    "WIRE",
    "SOCKET",
    "CAT",
    "DOG",
    "DESK_RECT",
    "DESK_CIRCLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameClassID(ClassID e) {
  if (flatbuffers::IsOutRange(e, ClassID_UNKNOWN, ClassID_DESK_CIRCLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesClassID()[index];
}

enum SenmaticStatus {
  SenmaticStatus_NO_UPDATE = 0,
  SenmaticStatus_UPDATE = 1,
  SenmaticStatus_MIN = SenmaticStatus_NO_UPDATE,
  SenmaticStatus_MAX = SenmaticStatus_UPDATE
};

inline const SenmaticStatus (&EnumValuesSenmaticStatus())[2] {
  static const SenmaticStatus values[] = {
    SenmaticStatus_NO_UPDATE,
    SenmaticStatus_UPDATE
  };
  return values;
}

inline const char * const *EnumNamesSenmaticStatus() {
  static const char * const names[3] = {
    "NO_UPDATE",
    "UPDATE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSenmaticStatus(SenmaticStatus e) {
  if (flatbuffers::IsOutRange(e, SenmaticStatus_NO_UPDATE, SenmaticStatus_UPDATE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSenmaticStatus()[index];
}

enum ServerType {
  ServerType_NONE = 0,
  ServerType_ServerRptImage = 1,
  ServerType_ServerRptOccupancyGrid = 2,
  ServerType_ServerRespSn = 3,
  ServerType_ServerRptWorkingState = 4,
  ServerType_ServerRespSpeed = 5,
  ServerType_ServerRespStop = 6,
  ServerType_ServerRptPose = 7,
  ServerType_ServerRespSwitchAuto = 8,
  ServerType_ServerRespSwitchManual = 9,
  ServerType_ServerRespAutoStart = 10,
  ServerType_ServerRptSenmaticMap = 11,
  ServerType_ServerRespMapList = 12,
  ServerType_ServerRespMapOccupancyGrid = 13,
  ServerType_ServerRespMapSemantics = 14,
  ServerType_ServerRespStartRegion = 15,
  ServerType_ServerRespSceneDesc = 16,
  ServerType_ServerRespAddSceneDesc = 17,
  ServerType_ServerRespDelSceneDesc = 18,
  ServerType_ServerRespSetState = 19,
  ServerType_ServerRptChangeMap = 20,
  ServerType_ServerRptRelocationFailed = 21,
  ServerType_ServerRptFinishStatus = 22,
  ServerType_ServerRespRecharge = 23,
  ServerType_ServerRespAddTimer = 24,
  ServerType_ServerRespUpdateTimer = 25,
  ServerType_ServerRespDelTimer = 26,
  ServerType_ServerRespListTimer = 27,
  ServerType_MIN = ServerType_NONE,
  ServerType_MAX = ServerType_ServerRespListTimer
};

inline const ServerType (&EnumValuesServerType())[28] {
  static const ServerType values[] = {
    ServerType_NONE,
    ServerType_ServerRptImage,
    ServerType_ServerRptOccupancyGrid,
    ServerType_ServerRespSn,
    ServerType_ServerRptWorkingState,
    ServerType_ServerRespSpeed,
    ServerType_ServerRespStop,
    ServerType_ServerRptPose,
    ServerType_ServerRespSwitchAuto,
    ServerType_ServerRespSwitchManual,
    ServerType_ServerRespAutoStart,
    ServerType_ServerRptSenmaticMap,
    ServerType_ServerRespMapList,
    ServerType_ServerRespMapOccupancyGrid,
    ServerType_ServerRespMapSemantics,
    ServerType_ServerRespStartRegion,
    ServerType_ServerRespSceneDesc,
    ServerType_ServerRespAddSceneDesc,
    ServerType_ServerRespDelSceneDesc,
    ServerType_ServerRespSetState,
    ServerType_ServerRptChangeMap,
    ServerType_ServerRptRelocationFailed,
    ServerType_ServerRptFinishStatus,
    ServerType_ServerRespRecharge,
    ServerType_ServerRespAddTimer,
    ServerType_ServerRespUpdateTimer,
    ServerType_ServerRespDelTimer,
    ServerType_ServerRespListTimer
  };
  return values;
}

inline const char * const *EnumNamesServerType() {
  static const char * const names[29] = {
    "NONE",
    "ServerRptImage",
    "ServerRptOccupancyGrid",
    "ServerRespSn",
    "ServerRptWorkingState",
    "ServerRespSpeed",
    "ServerRespStop",
    "ServerRptPose",
    "ServerRespSwitchAuto",
    "ServerRespSwitchManual",
    "ServerRespAutoStart",
    "ServerRptSenmaticMap",
    "ServerRespMapList",
    "ServerRespMapOccupancyGrid",
    "ServerRespMapSemantics",
    "ServerRespStartRegion",
    "ServerRespSceneDesc",
    "ServerRespAddSceneDesc",
    "ServerRespDelSceneDesc",
    "ServerRespSetState",
    "ServerRptChangeMap",
    "ServerRptRelocationFailed",
    "ServerRptFinishStatus",
    "ServerRespRecharge",
    "ServerRespAddTimer",
    "ServerRespUpdateTimer",
    "ServerRespDelTimer",
    "ServerRespListTimer",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerType(ServerType e) {
  if (flatbuffers::IsOutRange(e, ServerType_NONE, ServerType_ServerRespListTimer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerType()[index];
}

template<typename T> struct ServerTypeTraits {
  static const ServerType enum_value = ServerType_NONE;
};

template<> struct ServerTypeTraits<abby::ServerRptImage> {
  static const ServerType enum_value = ServerType_ServerRptImage;
};

template<> struct ServerTypeTraits<abby::ServerRptOccupancyGrid> {
  static const ServerType enum_value = ServerType_ServerRptOccupancyGrid;
};

template<> struct ServerTypeTraits<abby::ServerRespSn> {
  static const ServerType enum_value = ServerType_ServerRespSn;
};

template<> struct ServerTypeTraits<abby::ServerRptWorkingState> {
  static const ServerType enum_value = ServerType_ServerRptWorkingState;
};

template<> struct ServerTypeTraits<abby::ServerRespSpeed> {
  static const ServerType enum_value = ServerType_ServerRespSpeed;
};

template<> struct ServerTypeTraits<abby::ServerRespStop> {
  static const ServerType enum_value = ServerType_ServerRespStop;
};

template<> struct ServerTypeTraits<abby::ServerRptPose> {
  static const ServerType enum_value = ServerType_ServerRptPose;
};

template<> struct ServerTypeTraits<abby::ServerRespSwitchAuto> {
  static const ServerType enum_value = ServerType_ServerRespSwitchAuto;
};

template<> struct ServerTypeTraits<abby::ServerRespSwitchManual> {
  static const ServerType enum_value = ServerType_ServerRespSwitchManual;
};

template<> struct ServerTypeTraits<abby::ServerRespAutoStart> {
  static const ServerType enum_value = ServerType_ServerRespAutoStart;
};

template<> struct ServerTypeTraits<abby::ServerRptSenmaticMap> {
  static const ServerType enum_value = ServerType_ServerRptSenmaticMap;
};

template<> struct ServerTypeTraits<abby::ServerRespMapList> {
  static const ServerType enum_value = ServerType_ServerRespMapList;
};

template<> struct ServerTypeTraits<abby::ServerRespMapOccupancyGrid> {
  static const ServerType enum_value = ServerType_ServerRespMapOccupancyGrid;
};

template<> struct ServerTypeTraits<abby::ServerRespMapSemantics> {
  static const ServerType enum_value = ServerType_ServerRespMapSemantics;
};

template<> struct ServerTypeTraits<abby::ServerRespStartRegion> {
  static const ServerType enum_value = ServerType_ServerRespStartRegion;
};

template<> struct ServerTypeTraits<abby::ServerRespSceneDesc> {
  static const ServerType enum_value = ServerType_ServerRespSceneDesc;
};

template<> struct ServerTypeTraits<abby::ServerRespAddSceneDesc> {
  static const ServerType enum_value = ServerType_ServerRespAddSceneDesc;
};

template<> struct ServerTypeTraits<abby::ServerRespDelSceneDesc> {
  static const ServerType enum_value = ServerType_ServerRespDelSceneDesc;
};

template<> struct ServerTypeTraits<abby::ServerRespSetState> {
  static const ServerType enum_value = ServerType_ServerRespSetState;
};

template<> struct ServerTypeTraits<abby::ServerRptChangeMap> {
  static const ServerType enum_value = ServerType_ServerRptChangeMap;
};

template<> struct ServerTypeTraits<abby::ServerRptRelocationFailed> {
  static const ServerType enum_value = ServerType_ServerRptRelocationFailed;
};

template<> struct ServerTypeTraits<abby::ServerRptFinishStatus> {
  static const ServerType enum_value = ServerType_ServerRptFinishStatus;
};

template<> struct ServerTypeTraits<abby::ServerRespRecharge> {
  static const ServerType enum_value = ServerType_ServerRespRecharge;
};

template<> struct ServerTypeTraits<abby::ServerRespAddTimer> {
  static const ServerType enum_value = ServerType_ServerRespAddTimer;
};

template<> struct ServerTypeTraits<abby::ServerRespUpdateTimer> {
  static const ServerType enum_value = ServerType_ServerRespUpdateTimer;
};

template<> struct ServerTypeTraits<abby::ServerRespDelTimer> {
  static const ServerType enum_value = ServerType_ServerRespDelTimer;
};

template<> struct ServerTypeTraits<abby::ServerRespListTimer> {
  static const ServerType enum_value = ServerType_ServerRespListTimer;
};

bool VerifyServerType(flatbuffers::Verifier &verifier, const void *obj, ServerType type);
bool VerifyServerTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ServerRptImage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRptImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WEIGHT = 6,
    VT_IMAGE = 8
  };
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  int32_t weight() const {
    return GetField<int32_t>(VT_WEIGHT, 0);
  }
  const flatbuffers::Vector<uint8_t> *image() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_IMAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WEIGHT) &&
           VerifyOffset(verifier, VT_IMAGE) &&
           verifier.VerifyVector(image()) &&
           verifier.EndTable();
  }
};

struct ServerRptImageBuilder {
  typedef ServerRptImage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(ServerRptImage::VT_HEIGHT, height, 0);
  }
  void add_weight(int32_t weight) {
    fbb_.AddElement<int32_t>(ServerRptImage::VT_WEIGHT, weight, 0);
  }
  void add_image(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> image) {
    fbb_.AddOffset(ServerRptImage::VT_IMAGE, image);
  }
  explicit ServerRptImageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRptImageBuilder &operator=(const ServerRptImageBuilder &);
  flatbuffers::Offset<ServerRptImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRptImage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRptImage> CreateServerRptImage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> image = 0) {
  ServerRptImageBuilder builder_(_fbb);
  builder_.add_image(image);
  builder_.add_weight(weight);
  builder_.add_height(height);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerRptImage> CreateServerRptImageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t weight = 0,
    const std::vector<uint8_t> *image = nullptr) {
  auto image__ = image ? _fbb.CreateVector<uint8_t>(*image) : 0;
  return abby::CreateServerRptImage(
      _fbb,
      height,
      weight,
      image__);
}

struct ServerGrid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_VALUE = 8
  };
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ServerGridBuilder {
  typedef ServerGrid Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(ServerGrid::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(ServerGrid::VT_Y, y, 0);
  }
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(ServerGrid::VT_VALUE, value, 0);
  }
  explicit ServerGridBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerGridBuilder &operator=(const ServerGridBuilder &);
  flatbuffers::Offset<ServerGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerGrid>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerGrid> CreateServerGrid(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x = 0,
    int32_t y = 0,
    int8_t value = 0) {
  ServerGridBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ServerRptOccupancyGrid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRptOccupancyGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_WIFTH = 6,
    VT_HEIGHT = 8,
    VT_RESOLUTION = 10,
    VT_GRID_DATA = 12
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  int32_t wifth() const {
    return GetField<int32_t>(VT_WIFTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  float resolution() const {
    return GetField<float>(VT_RESOLUTION, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<abby::ServerGrid>> *grid_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::ServerGrid>> *>(VT_GRID_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           VerifyField<int32_t>(verifier, VT_WIFTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_RESOLUTION) &&
           VerifyOffset(verifier, VT_GRID_DATA) &&
           verifier.VerifyVector(grid_data()) &&
           verifier.VerifyVectorOfTables(grid_data()) &&
           verifier.EndTable();
  }
};

struct ServerRptOccupancyGridBuilder {
  typedef ServerRptOccupancyGrid Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ServerRptOccupancyGrid::VT_TIME, time, 0);
  }
  void add_wifth(int32_t wifth) {
    fbb_.AddElement<int32_t>(ServerRptOccupancyGrid::VT_WIFTH, wifth, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(ServerRptOccupancyGrid::VT_HEIGHT, height, 0);
  }
  void add_resolution(float resolution) {
    fbb_.AddElement<float>(ServerRptOccupancyGrid::VT_RESOLUTION, resolution, 0.0f);
  }
  void add_grid_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::ServerGrid>>> grid_data) {
    fbb_.AddOffset(ServerRptOccupancyGrid::VT_GRID_DATA, grid_data);
  }
  explicit ServerRptOccupancyGridBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRptOccupancyGridBuilder &operator=(const ServerRptOccupancyGridBuilder &);
  flatbuffers::Offset<ServerRptOccupancyGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRptOccupancyGrid>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRptOccupancyGrid> CreateServerRptOccupancyGrid(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    int32_t wifth = 0,
    int32_t height = 0,
    float resolution = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::ServerGrid>>> grid_data = 0) {
  ServerRptOccupancyGridBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_grid_data(grid_data);
  builder_.add_resolution(resolution);
  builder_.add_height(height);
  builder_.add_wifth(wifth);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerRptOccupancyGrid> CreateServerRptOccupancyGridDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0,
    int32_t wifth = 0,
    int32_t height = 0,
    float resolution = 0.0f,
    const std::vector<flatbuffers::Offset<abby::ServerGrid>> *grid_data = nullptr) {
  auto grid_data__ = grid_data ? _fbb.CreateVector<flatbuffers::Offset<abby::ServerGrid>>(*grid_data) : 0;
  return abby::CreateServerRptOccupancyGrid(
      _fbb,
      time,
      wifth,
      height,
      resolution,
      grid_data__);
}

struct ServerRespSn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespSnBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SN = 4
  };
  const flatbuffers::String *sn() const {
    return GetPointer<const flatbuffers::String *>(VT_SN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SN) &&
           verifier.VerifyString(sn()) &&
           verifier.EndTable();
  }
};

struct ServerRespSnBuilder {
  typedef ServerRespSn Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sn(flatbuffers::Offset<flatbuffers::String> sn) {
    fbb_.AddOffset(ServerRespSn::VT_SN, sn);
  }
  explicit ServerRespSnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespSnBuilder &operator=(const ServerRespSnBuilder &);
  flatbuffers::Offset<ServerRespSn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespSn>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespSn> CreateServerRespSn(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sn = 0) {
  ServerRespSnBuilder builder_(_fbb);
  builder_.add_sn(sn);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerRespSn> CreateServerRespSnDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sn = nullptr) {
  auto sn__ = sn ? _fbb.CreateString(sn) : 0;
  return abby::CreateServerRespSn(
      _fbb,
      sn__);
}

struct ServerRptWorkingState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRptWorkingStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  abby::WorkingType state() const {
    return static_cast<abby::WorkingType>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct ServerRptWorkingStateBuilder {
  typedef ServerRptWorkingState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(abby::WorkingType state) {
    fbb_.AddElement<int8_t>(ServerRptWorkingState::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit ServerRptWorkingStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRptWorkingStateBuilder &operator=(const ServerRptWorkingStateBuilder &);
  flatbuffers::Offset<ServerRptWorkingState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRptWorkingState>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRptWorkingState> CreateServerRptWorkingState(
    flatbuffers::FlatBufferBuilder &_fbb,
    abby::WorkingType state = abby::WorkingType_Ready) {
  ServerRptWorkingStateBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct ServerRespSpeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespSpeedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespSpeedBuilder {
  typedef ServerRespSpeed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespSpeed::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespSpeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespSpeedBuilder &operator=(const ServerRespSpeedBuilder &);
  flatbuffers::Offset<ServerRespSpeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespSpeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespSpeed> CreateServerRespSpeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespSpeedBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRespStop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespStopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespStopBuilder {
  typedef ServerRespStop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespStop::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespStopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespStopBuilder &operator=(const ServerRespStopBuilder &);
  flatbuffers::Offset<ServerRespStop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespStop>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespStop> CreateServerRespStop(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespStopBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRptPose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRptPoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PX = 4,
    VT_PY = 6,
    VT_YAW = 8
  };
  float px() const {
    return GetField<float>(VT_PX, 0.0f);
  }
  float py() const {
    return GetField<float>(VT_PY, 0.0f);
  }
  float yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_PX) &&
           VerifyField<float>(verifier, VT_PY) &&
           VerifyField<float>(verifier, VT_YAW) &&
           verifier.EndTable();
  }
};

struct ServerRptPoseBuilder {
  typedef ServerRptPose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_px(float px) {
    fbb_.AddElement<float>(ServerRptPose::VT_PX, px, 0.0f);
  }
  void add_py(float py) {
    fbb_.AddElement<float>(ServerRptPose::VT_PY, py, 0.0f);
  }
  void add_yaw(float yaw) {
    fbb_.AddElement<float>(ServerRptPose::VT_YAW, yaw, 0.0f);
  }
  explicit ServerRptPoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRptPoseBuilder &operator=(const ServerRptPoseBuilder &);
  flatbuffers::Offset<ServerRptPose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRptPose>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRptPose> CreateServerRptPose(
    flatbuffers::FlatBufferBuilder &_fbb,
    float px = 0.0f,
    float py = 0.0f,
    float yaw = 0.0f) {
  ServerRptPoseBuilder builder_(_fbb);
  builder_.add_yaw(yaw);
  builder_.add_py(py);
  builder_.add_px(px);
  return builder_.Finish();
}

struct ServerRespSwitchAuto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespSwitchAutoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespSwitchAutoBuilder {
  typedef ServerRespSwitchAuto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespSwitchAuto::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespSwitchAutoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespSwitchAutoBuilder &operator=(const ServerRespSwitchAutoBuilder &);
  flatbuffers::Offset<ServerRespSwitchAuto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespSwitchAuto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespSwitchAuto> CreateServerRespSwitchAuto(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespSwitchAutoBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRespSwitchManual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespSwitchManualBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespSwitchManualBuilder {
  typedef ServerRespSwitchManual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespSwitchManual::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespSwitchManualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespSwitchManualBuilder &operator=(const ServerRespSwitchManualBuilder &);
  flatbuffers::Offset<ServerRespSwitchManual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespSwitchManual>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespSwitchManual> CreateServerRespSwitchManual(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespSwitchManualBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRespAutoStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespAutoStartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespAutoStartBuilder {
  typedef ServerRespAutoStart Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespAutoStart::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespAutoStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespAutoStartBuilder &operator=(const ServerRespAutoStartBuilder &);
  flatbuffers::Offset<ServerRespAutoStart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespAutoStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespAutoStart> CreateServerRespAutoStart(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespAutoStartBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct Point FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct PointBuilder {
  typedef Point Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Point::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Point::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Point::VT_Z, z, 0.0);
  }
  explicit PointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointBuilder &operator=(const PointBuilder &);
  flatbuffers::Offset<Point> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Point>(end);
    return o;
  }
};

inline flatbuffers::Offset<Point> CreatePoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  PointBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct ServerSenmaticObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerSenmaticObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASS_ID = 6,
    VT_LOCATION = 8,
    VT_STYPE = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  abby::ClassID class_id() const {
    return static_cast<abby::ClassID>(GetField<int8_t>(VT_CLASS_ID, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<abby::Point>> *location() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::Point>> *>(VT_LOCATION);
  }
  uint16_t stype() const {
    return GetField<uint16_t>(VT_STYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int8_t>(verifier, VT_CLASS_ID) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyVector(location()) &&
           verifier.VerifyVectorOfTables(location()) &&
           VerifyField<uint16_t>(verifier, VT_STYPE) &&
           verifier.EndTable();
  }
};

struct ServerSenmaticObjectBuilder {
  typedef ServerSenmaticObject Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(ServerSenmaticObject::VT_ID, id, 0);
  }
  void add_class_id(abby::ClassID class_id) {
    fbb_.AddElement<int8_t>(ServerSenmaticObject::VT_CLASS_ID, static_cast<int8_t>(class_id), 0);
  }
  void add_location(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Point>>> location) {
    fbb_.AddOffset(ServerSenmaticObject::VT_LOCATION, location);
  }
  void add_stype(uint16_t stype) {
    fbb_.AddElement<uint16_t>(ServerSenmaticObject::VT_STYPE, stype, 0);
  }
  explicit ServerSenmaticObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerSenmaticObjectBuilder &operator=(const ServerSenmaticObjectBuilder &);
  flatbuffers::Offset<ServerSenmaticObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerSenmaticObject>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerSenmaticObject> CreateServerSenmaticObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    abby::ClassID class_id = abby::ClassID_UNKNOWN,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Point>>> location = 0,
    uint16_t stype = 0) {
  ServerSenmaticObjectBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_id(id);
  builder_.add_stype(stype);
  builder_.add_class_id(class_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerSenmaticObject> CreateServerSenmaticObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    abby::ClassID class_id = abby::ClassID_UNKNOWN,
    const std::vector<flatbuffers::Offset<abby::Point>> *location = nullptr,
    uint16_t stype = 0) {
  auto location__ = location ? _fbb.CreateVector<flatbuffers::Offset<abby::Point>>(*location) : 0;
  return abby::CreateServerSenmaticObject(
      _fbb,
      id,
      class_id,
      location__,
      stype);
}

struct ServerRptSenmaticMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRptSenmaticMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_OBJECTS = 6
  };
  abby::SenmaticStatus status() const {
    return static_cast<abby::SenmaticStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<abby::ServerSenmaticObject>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::ServerSenmaticObject>> *>(VT_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

struct ServerRptSenmaticMapBuilder {
  typedef ServerRptSenmaticMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(abby::SenmaticStatus status) {
    fbb_.AddElement<int8_t>(ServerRptSenmaticMap::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::ServerSenmaticObject>>> objects) {
    fbb_.AddOffset(ServerRptSenmaticMap::VT_OBJECTS, objects);
  }
  explicit ServerRptSenmaticMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRptSenmaticMapBuilder &operator=(const ServerRptSenmaticMapBuilder &);
  flatbuffers::Offset<ServerRptSenmaticMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRptSenmaticMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRptSenmaticMap> CreateServerRptSenmaticMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    abby::SenmaticStatus status = abby::SenmaticStatus_NO_UPDATE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::ServerSenmaticObject>>> objects = 0) {
  ServerRptSenmaticMapBuilder builder_(_fbb);
  builder_.add_objects(objects);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerRptSenmaticMap> CreateServerRptSenmaticMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    abby::SenmaticStatus status = abby::SenmaticStatus_NO_UPDATE,
    const std::vector<flatbuffers::Offset<abby::ServerSenmaticObject>> *objects = nullptr) {
  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<abby::ServerSenmaticObject>>(*objects) : 0;
  return abby::CreateServerRptSenmaticMap(
      _fbb,
      status,
      objects__);
}

struct ServerRespMapList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespMapListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIST = 4,
    VT_SUCCESS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<abby::MapInfo>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::MapInfo>> *>(VT_LIST);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyVector(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespMapListBuilder {
  typedef ServerRespMapList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::MapInfo>>> list) {
    fbb_.AddOffset(ServerRespMapList::VT_LIST, list);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespMapList::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespMapListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespMapListBuilder &operator=(const ServerRespMapListBuilder &);
  flatbuffers::Offset<ServerRespMapList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespMapList>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespMapList> CreateServerRespMapList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::MapInfo>>> list = 0,
    bool success = false) {
  ServerRespMapListBuilder builder_(_fbb);
  builder_.add_list(list);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerRespMapList> CreateServerRespMapListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<abby::MapInfo>> *list = nullptr,
    bool success = false) {
  auto list__ = list ? _fbb.CreateVector<flatbuffers::Offset<abby::MapInfo>>(*list) : 0;
  return abby::CreateServerRespMapList(
      _fbb,
      list__,
      success);
}

struct ServerRespMapOccupancyGrid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespMapOccupancyGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIFTH = 4,
    VT_HEIGHT = 6,
    VT_RESOLUTION = 8,
    VT_GRID_DATA = 10,
    VT_SUCCESS = 12
  };
  int32_t wifth() const {
    return GetField<int32_t>(VT_WIFTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  float resolution() const {
    return GetField<float>(VT_RESOLUTION, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<abby::ServerGrid>> *grid_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::ServerGrid>> *>(VT_GRID_DATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WIFTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_RESOLUTION) &&
           VerifyOffset(verifier, VT_GRID_DATA) &&
           verifier.VerifyVector(grid_data()) &&
           verifier.VerifyVectorOfTables(grid_data()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespMapOccupancyGridBuilder {
  typedef ServerRespMapOccupancyGrid Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wifth(int32_t wifth) {
    fbb_.AddElement<int32_t>(ServerRespMapOccupancyGrid::VT_WIFTH, wifth, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(ServerRespMapOccupancyGrid::VT_HEIGHT, height, 0);
  }
  void add_resolution(float resolution) {
    fbb_.AddElement<float>(ServerRespMapOccupancyGrid::VT_RESOLUTION, resolution, 0.0f);
  }
  void add_grid_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::ServerGrid>>> grid_data) {
    fbb_.AddOffset(ServerRespMapOccupancyGrid::VT_GRID_DATA, grid_data);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespMapOccupancyGrid::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespMapOccupancyGridBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespMapOccupancyGridBuilder &operator=(const ServerRespMapOccupancyGridBuilder &);
  flatbuffers::Offset<ServerRespMapOccupancyGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespMapOccupancyGrid>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespMapOccupancyGrid> CreateServerRespMapOccupancyGrid(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t wifth = 0,
    int32_t height = 0,
    float resolution = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::ServerGrid>>> grid_data = 0,
    bool success = false) {
  ServerRespMapOccupancyGridBuilder builder_(_fbb);
  builder_.add_grid_data(grid_data);
  builder_.add_resolution(resolution);
  builder_.add_height(height);
  builder_.add_wifth(wifth);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerRespMapOccupancyGrid> CreateServerRespMapOccupancyGridDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t wifth = 0,
    int32_t height = 0,
    float resolution = 0.0f,
    const std::vector<flatbuffers::Offset<abby::ServerGrid>> *grid_data = nullptr,
    bool success = false) {
  auto grid_data__ = grid_data ? _fbb.CreateVector<flatbuffers::Offset<abby::ServerGrid>>(*grid_data) : 0;
  return abby::CreateServerRespMapOccupancyGrid(
      _fbb,
      wifth,
      height,
      resolution,
      grid_data__,
      success);
}

struct ServerRespMapSemantics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespMapSemanticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTS = 4,
    VT_SUCCESS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<abby::ServerSenmaticObject>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::ServerSenmaticObject>> *>(VT_OBJECTS);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespMapSemanticsBuilder {
  typedef ServerRespMapSemantics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::ServerSenmaticObject>>> objects) {
    fbb_.AddOffset(ServerRespMapSemantics::VT_OBJECTS, objects);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespMapSemantics::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespMapSemanticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespMapSemanticsBuilder &operator=(const ServerRespMapSemanticsBuilder &);
  flatbuffers::Offset<ServerRespMapSemantics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespMapSemantics>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespMapSemantics> CreateServerRespMapSemantics(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::ServerSenmaticObject>>> objects = 0,
    bool success = false) {
  ServerRespMapSemanticsBuilder builder_(_fbb);
  builder_.add_objects(objects);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerRespMapSemantics> CreateServerRespMapSemanticsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<abby::ServerSenmaticObject>> *objects = nullptr,
    bool success = false) {
  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<abby::ServerSenmaticObject>>(*objects) : 0;
  return abby::CreateServerRespMapSemantics(
      _fbb,
      objects__,
      success);
}

struct ServerRespStartRegion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespStartRegionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespStartRegionBuilder {
  typedef ServerRespStartRegion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespStartRegion::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespStartRegionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespStartRegionBuilder &operator=(const ServerRespStartRegionBuilder &);
  flatbuffers::Offset<ServerRespStartRegion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespStartRegion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespStartRegion> CreateServerRespStartRegion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespStartRegionBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRespSceneDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespSceneDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESC = 4,
    VT_SUCCESS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<abby::Outline>> *desc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::Outline>> *>(VT_DESC);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.VerifyVector(desc()) &&
           verifier.VerifyVectorOfTables(desc()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespSceneDescBuilder {
  typedef ServerRespSceneDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_desc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Outline>>> desc) {
    fbb_.AddOffset(ServerRespSceneDesc::VT_DESC, desc);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespSceneDesc::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespSceneDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespSceneDescBuilder &operator=(const ServerRespSceneDescBuilder &);
  flatbuffers::Offset<ServerRespSceneDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespSceneDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespSceneDesc> CreateServerRespSceneDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::Outline>>> desc = 0,
    bool success = false) {
  ServerRespSceneDescBuilder builder_(_fbb);
  builder_.add_desc(desc);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerRespSceneDesc> CreateServerRespSceneDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<abby::Outline>> *desc = nullptr,
    bool success = false) {
  auto desc__ = desc ? _fbb.CreateVector<flatbuffers::Offset<abby::Outline>>(*desc) : 0;
  return abby::CreateServerRespSceneDesc(
      _fbb,
      desc__,
      success);
}

struct ServerRespAddSceneDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespAddSceneDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespAddSceneDescBuilder {
  typedef ServerRespAddSceneDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespAddSceneDesc::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespAddSceneDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespAddSceneDescBuilder &operator=(const ServerRespAddSceneDescBuilder &);
  flatbuffers::Offset<ServerRespAddSceneDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespAddSceneDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespAddSceneDesc> CreateServerRespAddSceneDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespAddSceneDescBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRespDelSceneDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespDelSceneDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespDelSceneDescBuilder {
  typedef ServerRespDelSceneDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespDelSceneDesc::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespDelSceneDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespDelSceneDescBuilder &operator=(const ServerRespDelSceneDescBuilder &);
  flatbuffers::Offset<ServerRespDelSceneDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespDelSceneDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespDelSceneDesc> CreateServerRespDelSceneDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespDelSceneDescBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRespSetState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespSetStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespSetStateBuilder {
  typedef ServerRespSetState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespSetState::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespSetStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespSetStateBuilder &operator=(const ServerRespSetStateBuilder &);
  flatbuffers::Offset<ServerRespSetState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespSetState>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespSetState> CreateServerRespSetState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespSetStateBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRptChangeMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRptChangeMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RELOCATION = 4,
    VT_SCENE_ID = 6,
    VT_MAP_ID = 8
  };
  bool relocation() const {
    return GetField<uint8_t>(VT_RELOCATION, 0) != 0;
  }
  int64_t scene_id() const {
    return GetField<int64_t>(VT_SCENE_ID, 0);
  }
  int64_t map_id() const {
    return GetField<int64_t>(VT_MAP_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RELOCATION) &&
           VerifyField<int64_t>(verifier, VT_SCENE_ID) &&
           VerifyField<int64_t>(verifier, VT_MAP_ID) &&
           verifier.EndTable();
  }
};

struct ServerRptChangeMapBuilder {
  typedef ServerRptChangeMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_relocation(bool relocation) {
    fbb_.AddElement<uint8_t>(ServerRptChangeMap::VT_RELOCATION, static_cast<uint8_t>(relocation), 0);
  }
  void add_scene_id(int64_t scene_id) {
    fbb_.AddElement<int64_t>(ServerRptChangeMap::VT_SCENE_ID, scene_id, 0);
  }
  void add_map_id(int64_t map_id) {
    fbb_.AddElement<int64_t>(ServerRptChangeMap::VT_MAP_ID, map_id, 0);
  }
  explicit ServerRptChangeMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRptChangeMapBuilder &operator=(const ServerRptChangeMapBuilder &);
  flatbuffers::Offset<ServerRptChangeMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRptChangeMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRptChangeMap> CreateServerRptChangeMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool relocation = false,
    int64_t scene_id = 0,
    int64_t map_id = 0) {
  ServerRptChangeMapBuilder builder_(_fbb);
  builder_.add_map_id(map_id);
  builder_.add_scene_id(scene_id);
  builder_.add_relocation(relocation);
  return builder_.Finish();
}

struct ServerRptRelocationFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRptRelocationFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ServerRptRelocationFailedBuilder {
  typedef ServerRptRelocationFailed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ServerRptRelocationFailed::VT_TIME, time, 0);
  }
  explicit ServerRptRelocationFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRptRelocationFailedBuilder &operator=(const ServerRptRelocationFailedBuilder &);
  flatbuffers::Offset<ServerRptRelocationFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRptRelocationFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRptRelocationFailed> CreateServerRptRelocationFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  ServerRptRelocationFailedBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ServerRptFinishStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRptFinishStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  abby::FinishStatus time() const {
    return static_cast<abby::FinishStatus>(GetField<int8_t>(VT_TIME, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ServerRptFinishStatusBuilder {
  typedef ServerRptFinishStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(abby::FinishStatus time) {
    fbb_.AddElement<int8_t>(ServerRptFinishStatus::VT_TIME, static_cast<int8_t>(time), 0);
  }
  explicit ServerRptFinishStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRptFinishStatusBuilder &operator=(const ServerRptFinishStatusBuilder &);
  flatbuffers::Offset<ServerRptFinishStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRptFinishStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRptFinishStatus> CreateServerRptFinishStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    abby::FinishStatus time = abby::FinishStatus_OK) {
  ServerRptFinishStatusBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ServerRespRecharge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespRechargeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct ServerRespRechargeBuilder {
  typedef ServerRespRecharge Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(ServerRespRecharge::VT_TIME, time, 0);
  }
  explicit ServerRespRechargeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespRechargeBuilder &operator=(const ServerRespRechargeBuilder &);
  flatbuffers::Offset<ServerRespRecharge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespRecharge>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespRecharge> CreateServerRespRecharge(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  ServerRespRechargeBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct ServerRespAddTimer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespAddTimerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespAddTimerBuilder {
  typedef ServerRespAddTimer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespAddTimer::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespAddTimerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespAddTimerBuilder &operator=(const ServerRespAddTimerBuilder &);
  flatbuffers::Offset<ServerRespAddTimer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespAddTimer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespAddTimer> CreateServerRespAddTimer(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespAddTimerBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRespUpdateTimer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespUpdateTimerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespUpdateTimerBuilder {
  typedef ServerRespUpdateTimer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespUpdateTimer::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespUpdateTimerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespUpdateTimerBuilder &operator=(const ServerRespUpdateTimerBuilder &);
  flatbuffers::Offset<ServerRespUpdateTimer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespUpdateTimer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespUpdateTimer> CreateServerRespUpdateTimer(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespUpdateTimerBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRespDelTimer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespDelTimerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ServerRespDelTimerBuilder {
  typedef ServerRespDelTimer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespDelTimer::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit ServerRespDelTimerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespDelTimerBuilder &operator=(const ServerRespDelTimerBuilder &);
  flatbuffers::Offset<ServerRespDelTimer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespDelTimer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespDelTimer> CreateServerRespDelTimer(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ServerRespDelTimerBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ServerRespListTimer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerRespListTimerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_TASKS = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<abby::TimerTask>> *tasks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<abby::TimerTask>> *>(VT_TASKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyOffset(verifier, VT_TASKS) &&
           verifier.VerifyVector(tasks()) &&
           verifier.VerifyVectorOfTables(tasks()) &&
           verifier.EndTable();
  }
};

struct ServerRespListTimerBuilder {
  typedef ServerRespListTimer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ServerRespListTimer::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_tasks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::TimerTask>>> tasks) {
    fbb_.AddOffset(ServerRespListTimer::VT_TASKS, tasks);
  }
  explicit ServerRespListTimerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerRespListTimerBuilder &operator=(const ServerRespListTimerBuilder &);
  flatbuffers::Offset<ServerRespListTimer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerRespListTimer>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerRespListTimer> CreateServerRespListTimer(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<abby::TimerTask>>> tasks = 0) {
  ServerRespListTimerBuilder builder_(_fbb);
  builder_.add_tasks(tasks);
  builder_.add_success(success);
  return builder_.Finish();
}

inline flatbuffers::Offset<ServerRespListTimer> CreateServerRespListTimerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const std::vector<flatbuffers::Offset<abby::TimerTask>> *tasks = nullptr) {
  auto tasks__ = tasks ? _fbb.CreateVector<flatbuffers::Offset<abby::TimerTask>>(*tasks) : 0;
  return abby::CreateServerRespListTimer(
      _fbb,
      success,
      tasks__);
}

struct ServerData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ServerDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  abby::ServerType message_type() const {
    return static_cast<abby::ServerType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const abby::ServerRptImage *message_as_ServerRptImage() const {
    return message_type() == abby::ServerType_ServerRptImage ? static_cast<const abby::ServerRptImage *>(message()) : nullptr;
  }
  const abby::ServerRptOccupancyGrid *message_as_ServerRptOccupancyGrid() const {
    return message_type() == abby::ServerType_ServerRptOccupancyGrid ? static_cast<const abby::ServerRptOccupancyGrid *>(message()) : nullptr;
  }
  const abby::ServerRespSn *message_as_ServerRespSn() const {
    return message_type() == abby::ServerType_ServerRespSn ? static_cast<const abby::ServerRespSn *>(message()) : nullptr;
  }
  const abby::ServerRptWorkingState *message_as_ServerRptWorkingState() const {
    return message_type() == abby::ServerType_ServerRptWorkingState ? static_cast<const abby::ServerRptWorkingState *>(message()) : nullptr;
  }
  const abby::ServerRespSpeed *message_as_ServerRespSpeed() const {
    return message_type() == abby::ServerType_ServerRespSpeed ? static_cast<const abby::ServerRespSpeed *>(message()) : nullptr;
  }
  const abby::ServerRespStop *message_as_ServerRespStop() const {
    return message_type() == abby::ServerType_ServerRespStop ? static_cast<const abby::ServerRespStop *>(message()) : nullptr;
  }
  const abby::ServerRptPose *message_as_ServerRptPose() const {
    return message_type() == abby::ServerType_ServerRptPose ? static_cast<const abby::ServerRptPose *>(message()) : nullptr;
  }
  const abby::ServerRespSwitchAuto *message_as_ServerRespSwitchAuto() const {
    return message_type() == abby::ServerType_ServerRespSwitchAuto ? static_cast<const abby::ServerRespSwitchAuto *>(message()) : nullptr;
  }
  const abby::ServerRespSwitchManual *message_as_ServerRespSwitchManual() const {
    return message_type() == abby::ServerType_ServerRespSwitchManual ? static_cast<const abby::ServerRespSwitchManual *>(message()) : nullptr;
  }
  const abby::ServerRespAutoStart *message_as_ServerRespAutoStart() const {
    return message_type() == abby::ServerType_ServerRespAutoStart ? static_cast<const abby::ServerRespAutoStart *>(message()) : nullptr;
  }
  const abby::ServerRptSenmaticMap *message_as_ServerRptSenmaticMap() const {
    return message_type() == abby::ServerType_ServerRptSenmaticMap ? static_cast<const abby::ServerRptSenmaticMap *>(message()) : nullptr;
  }
  const abby::ServerRespMapList *message_as_ServerRespMapList() const {
    return message_type() == abby::ServerType_ServerRespMapList ? static_cast<const abby::ServerRespMapList *>(message()) : nullptr;
  }
  const abby::ServerRespMapOccupancyGrid *message_as_ServerRespMapOccupancyGrid() const {
    return message_type() == abby::ServerType_ServerRespMapOccupancyGrid ? static_cast<const abby::ServerRespMapOccupancyGrid *>(message()) : nullptr;
  }
  const abby::ServerRespMapSemantics *message_as_ServerRespMapSemantics() const {
    return message_type() == abby::ServerType_ServerRespMapSemantics ? static_cast<const abby::ServerRespMapSemantics *>(message()) : nullptr;
  }
  const abby::ServerRespStartRegion *message_as_ServerRespStartRegion() const {
    return message_type() == abby::ServerType_ServerRespStartRegion ? static_cast<const abby::ServerRespStartRegion *>(message()) : nullptr;
  }
  const abby::ServerRespSceneDesc *message_as_ServerRespSceneDesc() const {
    return message_type() == abby::ServerType_ServerRespSceneDesc ? static_cast<const abby::ServerRespSceneDesc *>(message()) : nullptr;
  }
  const abby::ServerRespAddSceneDesc *message_as_ServerRespAddSceneDesc() const {
    return message_type() == abby::ServerType_ServerRespAddSceneDesc ? static_cast<const abby::ServerRespAddSceneDesc *>(message()) : nullptr;
  }
  const abby::ServerRespDelSceneDesc *message_as_ServerRespDelSceneDesc() const {
    return message_type() == abby::ServerType_ServerRespDelSceneDesc ? static_cast<const abby::ServerRespDelSceneDesc *>(message()) : nullptr;
  }
  const abby::ServerRespSetState *message_as_ServerRespSetState() const {
    return message_type() == abby::ServerType_ServerRespSetState ? static_cast<const abby::ServerRespSetState *>(message()) : nullptr;
  }
  const abby::ServerRptChangeMap *message_as_ServerRptChangeMap() const {
    return message_type() == abby::ServerType_ServerRptChangeMap ? static_cast<const abby::ServerRptChangeMap *>(message()) : nullptr;
  }
  const abby::ServerRptRelocationFailed *message_as_ServerRptRelocationFailed() const {
    return message_type() == abby::ServerType_ServerRptRelocationFailed ? static_cast<const abby::ServerRptRelocationFailed *>(message()) : nullptr;
  }
  const abby::ServerRptFinishStatus *message_as_ServerRptFinishStatus() const {
    return message_type() == abby::ServerType_ServerRptFinishStatus ? static_cast<const abby::ServerRptFinishStatus *>(message()) : nullptr;
  }
  const abby::ServerRespRecharge *message_as_ServerRespRecharge() const {
    return message_type() == abby::ServerType_ServerRespRecharge ? static_cast<const abby::ServerRespRecharge *>(message()) : nullptr;
  }
  const abby::ServerRespAddTimer *message_as_ServerRespAddTimer() const {
    return message_type() == abby::ServerType_ServerRespAddTimer ? static_cast<const abby::ServerRespAddTimer *>(message()) : nullptr;
  }
  const abby::ServerRespUpdateTimer *message_as_ServerRespUpdateTimer() const {
    return message_type() == abby::ServerType_ServerRespUpdateTimer ? static_cast<const abby::ServerRespUpdateTimer *>(message()) : nullptr;
  }
  const abby::ServerRespDelTimer *message_as_ServerRespDelTimer() const {
    return message_type() == abby::ServerType_ServerRespDelTimer ? static_cast<const abby::ServerRespDelTimer *>(message()) : nullptr;
  }
  const abby::ServerRespListTimer *message_as_ServerRespListTimer() const {
    return message_type() == abby::ServerType_ServerRespListTimer ? static_cast<const abby::ServerRespListTimer *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyServerType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const abby::ServerRptImage *ServerData::message_as<abby::ServerRptImage>() const {
  return message_as_ServerRptImage();
}

template<> inline const abby::ServerRptOccupancyGrid *ServerData::message_as<abby::ServerRptOccupancyGrid>() const {
  return message_as_ServerRptOccupancyGrid();
}

template<> inline const abby::ServerRespSn *ServerData::message_as<abby::ServerRespSn>() const {
  return message_as_ServerRespSn();
}

template<> inline const abby::ServerRptWorkingState *ServerData::message_as<abby::ServerRptWorkingState>() const {
  return message_as_ServerRptWorkingState();
}

template<> inline const abby::ServerRespSpeed *ServerData::message_as<abby::ServerRespSpeed>() const {
  return message_as_ServerRespSpeed();
}

template<> inline const abby::ServerRespStop *ServerData::message_as<abby::ServerRespStop>() const {
  return message_as_ServerRespStop();
}

template<> inline const abby::ServerRptPose *ServerData::message_as<abby::ServerRptPose>() const {
  return message_as_ServerRptPose();
}

template<> inline const abby::ServerRespSwitchAuto *ServerData::message_as<abby::ServerRespSwitchAuto>() const {
  return message_as_ServerRespSwitchAuto();
}

template<> inline const abby::ServerRespSwitchManual *ServerData::message_as<abby::ServerRespSwitchManual>() const {
  return message_as_ServerRespSwitchManual();
}

template<> inline const abby::ServerRespAutoStart *ServerData::message_as<abby::ServerRespAutoStart>() const {
  return message_as_ServerRespAutoStart();
}

template<> inline const abby::ServerRptSenmaticMap *ServerData::message_as<abby::ServerRptSenmaticMap>() const {
  return message_as_ServerRptSenmaticMap();
}

template<> inline const abby::ServerRespMapList *ServerData::message_as<abby::ServerRespMapList>() const {
  return message_as_ServerRespMapList();
}

template<> inline const abby::ServerRespMapOccupancyGrid *ServerData::message_as<abby::ServerRespMapOccupancyGrid>() const {
  return message_as_ServerRespMapOccupancyGrid();
}

template<> inline const abby::ServerRespMapSemantics *ServerData::message_as<abby::ServerRespMapSemantics>() const {
  return message_as_ServerRespMapSemantics();
}

template<> inline const abby::ServerRespStartRegion *ServerData::message_as<abby::ServerRespStartRegion>() const {
  return message_as_ServerRespStartRegion();
}

template<> inline const abby::ServerRespSceneDesc *ServerData::message_as<abby::ServerRespSceneDesc>() const {
  return message_as_ServerRespSceneDesc();
}

template<> inline const abby::ServerRespAddSceneDesc *ServerData::message_as<abby::ServerRespAddSceneDesc>() const {
  return message_as_ServerRespAddSceneDesc();
}

template<> inline const abby::ServerRespDelSceneDesc *ServerData::message_as<abby::ServerRespDelSceneDesc>() const {
  return message_as_ServerRespDelSceneDesc();
}

template<> inline const abby::ServerRespSetState *ServerData::message_as<abby::ServerRespSetState>() const {
  return message_as_ServerRespSetState();
}

template<> inline const abby::ServerRptChangeMap *ServerData::message_as<abby::ServerRptChangeMap>() const {
  return message_as_ServerRptChangeMap();
}

template<> inline const abby::ServerRptRelocationFailed *ServerData::message_as<abby::ServerRptRelocationFailed>() const {
  return message_as_ServerRptRelocationFailed();
}

template<> inline const abby::ServerRptFinishStatus *ServerData::message_as<abby::ServerRptFinishStatus>() const {
  return message_as_ServerRptFinishStatus();
}

template<> inline const abby::ServerRespRecharge *ServerData::message_as<abby::ServerRespRecharge>() const {
  return message_as_ServerRespRecharge();
}

template<> inline const abby::ServerRespAddTimer *ServerData::message_as<abby::ServerRespAddTimer>() const {
  return message_as_ServerRespAddTimer();
}

template<> inline const abby::ServerRespUpdateTimer *ServerData::message_as<abby::ServerRespUpdateTimer>() const {
  return message_as_ServerRespUpdateTimer();
}

template<> inline const abby::ServerRespDelTimer *ServerData::message_as<abby::ServerRespDelTimer>() const {
  return message_as_ServerRespDelTimer();
}

template<> inline const abby::ServerRespListTimer *ServerData::message_as<abby::ServerRespListTimer>() const {
  return message_as_ServerRespListTimer();
}

struct ServerDataBuilder {
  typedef ServerData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(abby::ServerType message_type) {
    fbb_.AddElement<uint8_t>(ServerData::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(ServerData::VT_MESSAGE, message);
  }
  explicit ServerDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ServerDataBuilder &operator=(const ServerDataBuilder &);
  flatbuffers::Offset<ServerData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ServerData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ServerData> CreateServerData(
    flatbuffers::FlatBufferBuilder &_fbb,
    abby::ServerType message_type = abby::ServerType_NONE,
    flatbuffers::Offset<void> message = 0) {
  ServerDataBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyServerType(flatbuffers::Verifier &verifier, const void *obj, ServerType type) {
  switch (type) {
    case ServerType_NONE: {
      return true;
    }
    case ServerType_ServerRptImage: {
      auto ptr = reinterpret_cast<const abby::ServerRptImage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRptOccupancyGrid: {
      auto ptr = reinterpret_cast<const abby::ServerRptOccupancyGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespSn: {
      auto ptr = reinterpret_cast<const abby::ServerRespSn *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRptWorkingState: {
      auto ptr = reinterpret_cast<const abby::ServerRptWorkingState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespSpeed: {
      auto ptr = reinterpret_cast<const abby::ServerRespSpeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespStop: {
      auto ptr = reinterpret_cast<const abby::ServerRespStop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRptPose: {
      auto ptr = reinterpret_cast<const abby::ServerRptPose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespSwitchAuto: {
      auto ptr = reinterpret_cast<const abby::ServerRespSwitchAuto *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespSwitchManual: {
      auto ptr = reinterpret_cast<const abby::ServerRespSwitchManual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespAutoStart: {
      auto ptr = reinterpret_cast<const abby::ServerRespAutoStart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRptSenmaticMap: {
      auto ptr = reinterpret_cast<const abby::ServerRptSenmaticMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespMapList: {
      auto ptr = reinterpret_cast<const abby::ServerRespMapList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespMapOccupancyGrid: {
      auto ptr = reinterpret_cast<const abby::ServerRespMapOccupancyGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespMapSemantics: {
      auto ptr = reinterpret_cast<const abby::ServerRespMapSemantics *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespStartRegion: {
      auto ptr = reinterpret_cast<const abby::ServerRespStartRegion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespSceneDesc: {
      auto ptr = reinterpret_cast<const abby::ServerRespSceneDesc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespAddSceneDesc: {
      auto ptr = reinterpret_cast<const abby::ServerRespAddSceneDesc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespDelSceneDesc: {
      auto ptr = reinterpret_cast<const abby::ServerRespDelSceneDesc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespSetState: {
      auto ptr = reinterpret_cast<const abby::ServerRespSetState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRptChangeMap: {
      auto ptr = reinterpret_cast<const abby::ServerRptChangeMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRptRelocationFailed: {
      auto ptr = reinterpret_cast<const abby::ServerRptRelocationFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRptFinishStatus: {
      auto ptr = reinterpret_cast<const abby::ServerRptFinishStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespRecharge: {
      auto ptr = reinterpret_cast<const abby::ServerRespRecharge *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespAddTimer: {
      auto ptr = reinterpret_cast<const abby::ServerRespAddTimer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespUpdateTimer: {
      auto ptr = reinterpret_cast<const abby::ServerRespUpdateTimer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespDelTimer: {
      auto ptr = reinterpret_cast<const abby::ServerRespDelTimer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ServerType_ServerRespListTimer: {
      auto ptr = reinterpret_cast<const abby::ServerRespListTimer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyServerTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyServerType(
        verifier,  values->Get(i), types->GetEnum<ServerType>(i))) {
      return false;
    }
  }
  return true;
}

inline const abby::ServerData *GetServerData(const void *buf) {
  return flatbuffers::GetRoot<abby::ServerData>(buf);
}

inline const abby::ServerData *GetSizePrefixedServerData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<abby::ServerData>(buf);
}

inline bool VerifyServerDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<abby::ServerData>(nullptr);
}

inline bool VerifySizePrefixedServerDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<abby::ServerData>(nullptr);
}

inline void FinishServerDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<abby::ServerData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedServerDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<abby::ServerData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace abby

#endif  // FLATBUFFERS_GENERATED_S2C_ABBY_H_
